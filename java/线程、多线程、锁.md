# 线程、多线程、锁

## 线程

>线程就是进程中运行的多个子任务，是操作系统调用的最小单元。

**线程状态**

**1、初始(NEW)：** 新创建了一个线程对象，但还没有调用start()方法。  
**2、运行(RUNNABLE)：** Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。  
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。  
**3、阻塞(BLOCKED)：** 表示线程阻塞于锁。  
**4、等待(WAITING)：** 进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。  
**5、超时等待(TIMED_WAITING)：** 该状态不同于WAITING，它可以在指定的时间后自行返回。  
**6、终止(TERMINATED)：** 表示该线程已经执行完毕。  

**sleep() 、wait()、yield()、join() 的作用和区别**

**Thread.sleep(long millis)** 一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。  

**Object.wait()** 当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。  
<span>依靠notify()、notifyAll()唤醒或者wait(long timeout)timeout时间到自动唤醒。</span> 

**Thread.yield()** 一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。  
作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。  
Thread.yield()不会导致阻塞，该方法与sleep()类似，只是不能由用户指定暂停多长时间。  

**Thread.join()** 会让调用线程等待被调用线程结束后，才会继续执行。使用的场景为我们需要等待某个线程执行完成后才可继续执行的场景。

## 多线程三个特性

**原子性**：是指**一个操作是不可中断的**。即使是多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。  
比如，对于一个静态全局变量int i，两个线程同时对它赋值，线程A给他赋值为1，线程B给他赋值为-1。那么不管这两个线程以何种方式。何种步调工作，i的值要么是1，要么是-1，线程A和线程B之间是没有干扰的。这就是原子性的一个特点，不可被中断。

**可见性**：是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。显然，对于串行来说，可见性问题是不存在的。

**有序性**：在并发时，程序的执行可能会出现乱序。给人的直观感觉就是：写在前面的代码，会在后面执行。有序性问题的原因是因为**程序在执行时，可能会进行指令重排**，重排后的指令与原指令的顺序未必一致。

## 锁

**1、公平锁/非公平锁**（公平锁是指多个线程按照申请锁的顺序来获取锁）  
**2、可重入锁**（又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁）  
**3、独享锁/共享锁**（独享锁是指该锁一次只能被一个线程所持有）  
**4、互斥锁/读写锁**（ReentrantLock/ReadWriteLock）  
**5、乐观锁/悲观锁**（悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。）   
**6、分段锁**（分段锁其实是一种锁的设计，并不是具体的一种锁）  
**7、偏向锁/轻量级锁/重量级锁**（这三种锁是指锁的状态，并且是针对Synchronized）  
**8、自旋锁**（自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU）


### synchronized

synchronized提供了**同步锁**的概念，被synchronized修饰的代码段可以防止被多个线程同时执行，必须一个线程把synchronized修饰的代码段都执行完毕了，其他的线程才能开始执行这段代码。 因为synchronized保证了在同一时刻，只能有一个线程执行同步代码块，所以执行同步代码块的时候相当于是单线程操作了，那么线程的可见性、原子性、有序性（线程之间的执行顺序）它都能保证了。

### volatile

其实volatile关键字的作用就是保证了可见性和有序性（不保证[原子性](#多线程三个特性)），如果一个共享变量被volatile关键字修饰，那么如果一个线程修改了这个共享变量后，其他线程是立马可知的。  
**volatile能禁止指令重新排序**，在指令重排序优化时，在volatile变量之前的指令不能在volatile之后执行，在volatile之后的指令也不能在volatile之前执行，所以它保证了有序性。  

### ReentrantLock

ReentrantLock的实现是一种**自旋锁**，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。

**synchronized和volatile的区别**

1、volatile只能作用于变量，使用范围较小，synchronized可以用在方法、类、同步代码块等，使用范围比较广。  
2、volatile只能保证可见性和有序性，不能保证原子性。而可见性、有序性、原子性synchronized都可以保证。  
3、volatile不会造成线程阻塞，synchronized可能会造成线程阻塞。  

**synchronized和ReentrantLock的区别**  

1、ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。  
2、ReentrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。  
3、ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。  

**synchronized修饰实例方法和修饰静态方法的区别**

1、synchronized修饰实例方法是**对类的当前实例进行加锁**，防止其他线程同时访问该类的该实例的所有synchronized块，注意这里是“类的当前实例”，类的两个不同实例就没有这种约束了。  
2、synchronized修饰静态方法恰好就是要**控制类的所有实例**的访问了，static synchronized是限制线程同时访问jvm中该类的所有实例同时访问对应的代码块。

**同步实现原理**  
jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。

## 死锁产生条件，死锁应对策略

死锁发生的四个必要条件是：  
1、资源互斥使用。   
2、多个进程保持一定的资源，但又请求新的资源。   
3、资源不可被剥夺。   
4、多个进程循环等待。   

一般死锁的应对策略有：  
1、死锁预防：如进程需要的所有资源，在一开始就全部申请好得到之后再开始执行。   
2、死锁避免：如进程每次申请申请资源的时候，根据一定的算法，去看该请求可能不可能造成死锁，如果可能，就不给它分配该资源。   
3、死锁处理：破坏四个必要条件的其中一个，比如kill掉一个进程。   
4、死锁忽略：不管死锁，由用户自行处理，比如重启电脑。一般的系统其实都采取这种策略。