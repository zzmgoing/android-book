# 线程、多线程、锁

## 线程

>线程就是进程中运行的多个子任务，是操作系统调用的最小单元。

**线程状态**

**1、初始(NEW)：** 新创建了一个线程对象，但还没有调用start()方法。  
**2、运行(RUNNABLE)：** Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。  
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。  
**3、阻塞(BLOCKED)：** 表示线程阻塞于锁。  
**4、等待(WAITING)：** 进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。  
**5、超时等待(TIMED_WAITING)：** 该状态不同于WAITING，它可以在指定的时间后自行返回。  
**6、终止(TERMINATED)：** 表示该线程已经执行完毕。  

**sleep() 、wait()、yield()、join() 的作用和区别**

**Thread.sleep(long millis)** 一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。  

**Object.wait()** 当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。  
<span>依靠notify()、notifyAll()唤醒或者wait(long timeout)timeout时间到自动唤醒。</span> 

**Thread.yield()** 一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。  
作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。  
Thread.yield()不会导致阻塞，该方法与sleep()类似，只是不能由用户指定暂停多长时间。  

**Thread.join()** 会让调用线程等待被调用线程结束后，才会继续执行。使用的场景为我们需要等待某个线程执行完成后才可继续执行的场景。

## 多线程三个特性

**原子性**：是指**一个操作是不可中断的**。即使是多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。  
比如，对于一个静态全局变量int i，两个线程同时对它赋值，线程A给他赋值为1，线程B给他赋值为-1。那么不管这两个线程以何种方式。何种步调工作，i的值要么是1，要么是-1，线程A和线程B之间是没有干扰的。这就是原子性的一个特点，不可被中断。

**可见性**：是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。显然，对于串行来说，可见性问题是不存在的。

**有序性**：在并发时，程序的执行可能会出现乱序。给人的直观感觉就是：写在前面的代码，会在后面执行。有序性问题的原因是因为**程序在执行时，可能会进行指令重排**，重排后的指令与原指令的顺序未必一致。

## 锁

**1、公平锁/非公平锁**（公平锁是指多个线程按照申请锁的顺序来获取锁）  
**2、可重入锁**（又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁）  
**3、独享锁/共享锁**（独享锁是指该锁一次只能被一个线程所持有）  
**4、互斥锁/读写锁**（ReentrantLock/ReadWriteLock）  
**5、乐观锁/悲观锁**（悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。）   
**6、分段锁**（分段锁其实是一种锁的设计，并不是具体的一种锁）  
**7、偏向锁/轻量级锁/重量级锁**（这三种锁是指锁的状态，并且是针对Synchronized）  
**8、自旋锁**（自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU）


### synchronized

synchronized提供了**同步锁**的概念，被synchronized修饰的代码段可以防止被多个线程同时执行，必须一个线程把synchronized修饰的代码段都执行完毕了，其他的线程才能开始执行这段代码。 因为synchronized保证了在同一时刻，只能有一个线程执行同步代码块，所以执行同步代码块的时候相当于是单线程操作了，那么线程的可见性、原子性、有序性（线程之间的执行顺序）它都能保证了。

synchronized可以用来修饰以下3个层面：**修饰实例方法；修饰静态类方法；修饰代码块。**

**修饰实例方法：**  
锁是当前对象，只有同一个实例对象调用方法才会产生互斥效果，不同实例对象之间不会产生互斥效果。

**修饰静态类方法：**  
锁是当前类的Class对象，即使在不同线程中调用不同实例对象，也会有互斥效果。

**修饰代码块：**  
synchronized 作用于代码块时，锁对象就是跟在后面括号中的对象。任何Object对象都可以当作锁对象。

### volatile

其实volatile关键字的作用就是保证了可见性和有序性（不保证[原子性](#多线程三个特性)），如果一个共享变量被volatile关键字修饰，那么如果一个线程修改了这个共享变量后，其他线程是立马可知的。  
**volatile能禁止指令重新排序**，在指令重排序优化时，在volatile变量之前的指令不能在volatile之后执行，在volatile之后的指令也不能在volatile之前执行，所以它保证了有序性。  

### ReentrantLock

ReentrantLock的实现是一种**自旋锁**，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。

ReentrantLock 的使用同 synchronized 有点不同，它的加锁和解锁操作都需要手动完成。 **lock()** 和 **unlock()。**

默认情况下，synchronized 和 ReentrantLock 都是非公平锁。但是 ReentrantLock 可以通过传入 true 来创建一个公平锁。所谓公平锁就是通过同步队列来实现多个线程按照申请锁的顺序获取锁。

**synchronized和volatile的区别**

1、volatile只能作用于变量，使用范围较小，synchronized可以用在方法、类、同步代码块等，使用范围比较广。  
2、volatile只能保证可见性和有序性，不能保证原子性。而可见性、有序性、原子性synchronized都可以保证。  
3、volatile不会造成线程阻塞，synchronized可能会造成线程阻塞。  

**synchronized和ReentrantLock的区别**  

1、ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。  
2、ReentrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。  
3、ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。  

**同步实现原理**  
jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。

### Java 虚拟机对 synchronized 的优化

从 Java 6 开始，虚拟机对 synchronized 关键字做了多方面的优化，主要目的就是，避免 ObjectMonitor 的访问，减少“重量级锁”的使用次数，并最终减少线程上下文切换的频率 。其中主要做了以下几个优化： **锁自旋、轻量级锁、偏向锁**。  

**锁自旋**

所谓自旋，就是让该线程等待一段时间，不会被立即挂起，看当前持有锁的线程是否会很快释放锁。而所谓的等待就是执行一段无意义的循环即可（自旋）。  
<span>自旋锁也存在一定的缺陷：自旋锁要占用 CPU，如果锁竞争的时间比较长，那么自旋通常不能获得锁，白白浪费了自旋占用的 CPU 时间。这通常发生在锁持有时间长，且竞争激烈的场景中，此时应主动禁用自旋锁。</span>

**轻量级锁**

1、当线程执行某同步代码时，Java 虚拟机会在当前线程的栈帧中开辟一块空间（Lock Record）作为该锁的记录,  
2、然后 Java 虚拟机会尝试使用 CAS（Compare And Swap）操作，将锁对象的 Mark Word 拷贝到这块空间中，并且将锁记录中的 owner 指向 Mark Word。  
3、当线程再次执行此同步代码块时，判断当前对象的 Mark Word 是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁。  
<span>轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</span>

**偏向锁**

偏向锁的意思是如果一个线程获得了一个偏向锁，如果在接下来的一段时间中没有其他线程来竞争锁，那么持有偏向锁的线程再次进入或者退出同一个同步代码块，不需要再次进行抢占锁和释放锁的操作。  
<span>偏向锁的具体实现就是在锁对象的对象头中有个 ThreadId 字段，默认情况下这个字段是空的，当第一次获取锁的时候，就将自身的 ThreadId 写入锁对象的 Mark Word 中的 ThreadId 字段内，将是否偏向锁的状态置为 01。这样下次获取锁的时候，直接检查 ThreadId 是否和自身线程 Id 一致，如果一致，则认为当前线程已经获取了锁，因此不需再次获取锁，略过了轻量级锁和重量级锁的加锁阶段。提高了效率。</span>

### 深入理解 AQS 和 CAS 原理

**总结**

总体来说，**AQS 是一套框架，在框架内部已经封装好了大部分同步需要的逻辑**，在 AQS 内部维护了一个状态指示器 state 和一个等待队列 Node，而通过 state 的操作又分为两种：独占式和共享式，这就导致 AQS 有两种不同的实现：独占锁（ReentrantLock 等）和分享锁（CountDownLatch、读写锁等）。本课时主要从独占锁的角度深入分析了 AQS 的加锁和释放锁的流程。

理解 AQS 的原理对理解 JUC 包中其他组件实现的基础有帮助，并且理解其原理才能更好的扩展其功能。上层开发人员可以基于此框架基础上进行扩展实现适合不同场景、不同功能的锁。其中几个有可能需要子类同步器实现的方法如下。

1、lock()。  
2、tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。  
3、tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。  
4、tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。  
5、tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回 true，否则返回 false。  

**CAS 全称是 Compare And Swap，译为比较和替换，是一种通过硬件实现并发安全的常用技术**，底层通过利用 CPU 的 CAS 指令对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。

它的实现过程主要有 3 个操作数：内存值 V，旧的预期值 E，要修改的新值 U，当且仅当预期值 E和内存值 V 相同时，才将内存值 V 修改为 U，否则什么都不做。

CAS 底层会根据操作系统和处理器的不同来选择对应的调用代码，以 Windows 和 X86 处理器为例，如果是多处理器，通过带 lock 前缀的 cmpxchg 指令对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作；如果是单处理器，通过 cmpxchg 指令完成原子操作。


## 死锁产生条件，死锁应对策略

死锁发生的四个必要条件是：  
1、资源互斥使用。   
2、多个进程保持一定的资源，但又请求新的资源。   
3、资源不可被剥夺。   
4、多个进程循环等待。   

一般死锁的应对策略有：  
1、死锁预防：如进程需要的所有资源，在一开始就全部申请好得到之后再开始执行。   
2、死锁避免：如进程每次申请申请资源的时候，根据一定的算法，去看该请求可能不可能造成死锁，如果可能，就不给它分配该资源。   
3、死锁处理：破坏四个必要条件的其中一个，比如kill掉一个进程。   
4、死锁忽略：不管死锁，由用户自行处理，比如重启电脑。一般的系统其实都采取这种策略。