# TCP和UDP
  
>**TCP（Transmission Control Protocol，传输控制协议）提供的是面向连接，可靠的字节流服务**。即客户和服务器交换数据前，必须现在双方之间建立一个TCP连接，之后才能传输数据。并且提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。  

>**UDP（User Data Protocol，用户数据报协议）是一个简单的面向数据报的运输层协议**。它不提供可靠性，只是把应用程序传给IP层的数据报发送出去，但是不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。

**相同点：TCP协议和UDP协议都是传输层协议**。

**不同点：报头不同，特点不同，协议不同**。

**一、报头不同**

TCP报头最大长度60个字节。

UDP数据报最大长度64K（包含UDP首部），如果数据长度超过64K就需要在应用层手动分包，UDP无法保证包序，需要在应用层进行编号。

**二、特点不同**

**TCP特点：面向连接，可靠传输，面向字节流**

**1、面向连接**：客户端和服务端的[三次握手，四次挥手。](/java/TCP三次握手四次挥手.md)  
**2、可靠传输**：序列号，确认应答机制，超时重传，拥塞控制。  
<span>拥塞控制：每次发送数据包的时候, 将拥塞窗口和接收端主机反馈的窗口大小做比较, 取较小的值作为实际发送的窗口。提高传输的效率。</span>  
**3、面向字节流**：创建一个TCP的socket, 同时在内核中创建一个发送缓冲区和一个接收缓冲区；另一方面, TCP的一个连接, 既有发送缓冲区, 也有接收缓冲区, 那么对于这一个连接, 既可以读数据, 也可以写数据. 这个概念叫做全双工 。  

!>**TCP粘包问题**  
首先要明确, 粘包问题中的 “包” , 是指的应用层的数据包；在TCP的协议头中, 没有如同UDP一样的 “报文长度” 这样的字段, 但是有一个序号这样的字段；站在传输层的角度, TCP是一个一个报文过来的，按照序号排好序放在缓冲区中；站在应用层的角度, 看到的只是一串连续的字节数据. 那么应用程序看到了这么一连串的字节数据, 就不知道从哪个部分开始到哪个部分是一个完整的应用层数据包。  
**解决方案：明确两个包之间的边界**  
1、对于定长的包, 保证每次都按固定大小读取即可;  
2、对于变长的包, 可以在报头的位置, 约定一个包总长度的字段, 从而就知道了包的结束位置;  
3、对于变长的包, 还可以在包和包之间使用明确的分隔符；  
4、TLV格式的数据传输。

**UDP特点：无连接，不可靠，面向数据报，数据接收不够灵活**

**1、无连接**：知道对端的IP和端口号就直接进行传输, 不需要建立连接。  
**2、不可靠**：没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息。  
**3、面向数据报**：不能够灵活的控制读写数据的次数和数量，应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并。  
**4、数据接收不够灵活**，但是能够明确区分两个数据包，避免粘包问题。

**三、协议不同** 

TCP协议：**HTTP**(超文本传输协议)、**HTTPS**(超文本传输安全协议)、**SSH**(安全外壳协议)、**Telnet**(电信网络协议)、**FTP**(文件传输协议)、**SMTP**(简单邮件传输协议)

UDP协议：**NFS**(网络文件系统)、**TFTP**(简单文件传输协议)、**DHCP**(动态主机配置协议)、**BOOTP**(启动协议,用于无盘设备启动)、**DNS**(域名解析协议)