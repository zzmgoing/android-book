# JVM的内存分配

>Java 虚拟机在执行 Java 程序的过程中，会把它所管理的内存划分为不同的数据区域。

下面这张图描述了一个 HelloWorld.java 文件被 JVM 加载到内存中的过程：  
![jvm](https://img.upyun.zzming.cn/android/jvm_fp.png)
1、 HelloWorld.java 文件首先需要经过编译器编译，生成 HelloWorld.class 字节码文件。  
2、 Java 程序中访问HelloWorld这个类时，需要通过 ClassLoader(类加载器)将HelloWorld.class 加载到 JVM 的内存中。  
3、 JVM 中的内存可以划分为若干个不同的数据区域，主要分为：**程序计数器、虚拟机栈、本地方法栈、堆、方法区**。  

## 1、程序计数器
>程序计数器是虚拟机中一块较小的内存空间，主要用于记录当前线程执行的位置。

Java 程序是多线程的，CPU 可以在多个线程中分配执行时间片段。当某一个线程被 CPU 挂起时，需要记录代码已经执行到的位置，方便 CPU 重新执行此线程时，知道从哪行指令开始执行。这就是程序计数器的作用（分支操作、循环操作、跳转、异常处理）。

**注意：**  
a、在Java虚拟机规范中，对程序计数器这一区域没有规定任何OutOfMemoryError情况。  
b、线程私有的，每条线程内部都有一个私有程序计数器。它的生命周期随着线程的创建而创建，随着线程的结束而死亡。  
c、当一个线程正在执行一个Java方法的时候，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是Native方法，这个计数器值则为空（Undefined）。  

## 2、虚拟机栈
>虚拟机栈也是线程私有的，与线程的生命周期同步。

虚拟机栈的初衷是用来描述Java方法执行的内存模型，每个方法被执行的时候，JVM都会在虚拟机栈中创建一个栈帧。  
**栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，每一个线程在执行某个方法时，都会为这个方法创建一个栈帧。**  
一个线程包含多个栈帧，而每个栈帧内部包含**局部变量表、操作数栈、动态连接、返回地址**等。  

**1. 局部变量表**是变量值的存储空间，我们调用方法时传递的参数，以及在方法内部创建的局部变量都保存在局部变量表中。  
**2. 操作数栈**（Operand Stack）也常称为操作栈，它是一个后入先出栈（LIFO）。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的。在方法执行的过程中，会有各种字节码指令被压入和弹出操作数栈。  
**3. 动态链接**的主要目的是为了支持方法调用过程中的动态连接（Dynamic Linking）。在一个 class 文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其所在内存地址中的直接引用，而符号引用存在于方法区中。  
**4. 返回地址**作用是无论当前方法采用何种方式退出（正常退出/异常退出），在方法退出后都需要返回到方法被调用的位置，程序才能继续执行。而虚拟机栈中的“返回地址”就是用来帮助当前方法恢复它的上层方法执行状态。

## 3、本地方法栈

本地方法栈和上面介绍的虚拟栈基本相同，只不过是针对本地（native）方法。在开发中如果涉及 JNI 可能接触本地方法栈多一些，在有些虚拟机的实现中已经将两个合二为一了（比如HotSpot）。

## 4、堆
>用于存放对象实例。

Java 堆（Heap）是 JVM 所管理的内存中最大的一块，该区域唯一目的就是存放对象实例，几乎所有对象的实例都在堆里面分配，因此它也是 Java 垃圾收集器（GC）管理的主要区域，有时候也叫作“GC 堆”（关于堆的 GC 回收机制将会在后续课时中做详细介绍）。同时它也是**所有线程共享的内存区域**，因此被分配在此区域的对象如果被多个线程访问的话，需要考虑**线程安全**问题。

按照**对象存储时间**的不同，堆中的内存可以划分为**新生代**（Young）和**老年代**（Old），其中新生代又被划分为 Eden 和 Survivor 区。不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，进而提高垃圾回收效率。

## 5、方法区

方法区（Method Area）也是 JVM 规范里规定的一块**运行时数据区**。方法区主要是存储已经被**JVM 加载的类信息（版本、字段、方法、接口）、常量、静态变量、即时编译器编译后的代码和数据**。该区域同堆一样，也是被各个线程共享的内存区域。

**异常**  
**StackOverflowError** 栈溢出异常  
递归调用是造成StackOverflowError的一个常见场景。原因就是每调用一次method方法时，都会在虚拟机栈中创建出一个栈帧。因为是递归调用，method方法并不会退出，也不会将栈帧销毁，所以必然会导致StackOverflowError。因此当需要使用递归时，需要格外谨慎。

**OutOfMemoryError** 内存溢出异常  
理论上，虚拟机栈、堆、方法区都有发生OutOfMemoryError的可能。但是实际项目中，大多发生于堆当中。比如在一个无限循环中，动态的向ArrayList中添加新的HeapError对象。这会不断的占用堆中的内存，当堆内存不够时，必然会产生OutOfMemoryError，也就是内存溢出异常。

![jvm](https://img.upyun.zzming.cn/android/jvm_ing.png)

**总结**来说，JVM 的运行时内存结构中一共有**两个栈和一个堆，分别是：Java 虚拟机栈和本地方法栈，以及GC堆和方法区**。除此之外还有一个**程序计数器**，但是我们开发者几乎不会用到这一部分，所以并不是重点学习内容。 JVM 内存中只有堆和方法区是线程共享的数据区域，其它区域都是线程私有的。并且程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。
