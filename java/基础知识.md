# 基础知识

## TCP和UDP

TCP协议和UDP协议都是传输层协议。

TCP（Transmission Control Protocol，传输控制协议）提供的是**面向连接，可靠的字节流服务**。即客户和服务器交换数据前，必须现在双方之间建立一个TCP连接，之后才能传输数据。并且提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。

UDP（User Data Protocol，用户数据报协议）是一个简单的**面向数据报的运输层协议**。它不提供可靠性，只是把应用程序传给IP层的数据报发送出去，但是不能保证它们能到达目的地。由于UDP在传输数据报前不用再客户和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。

不同点：**报头不同，特点不同，协议不同**。

**TCP特点：**

TCP报头最大长度60个字节。

1、**面向连接**：客户端和服务端的[三次握手，四次挥手。](/java/TCP三次握手四次挥手.md)  
2、**可靠传输**：序列号，确认应答机制，超时重传，拥塞控制。  
<span>拥塞控制：每次发送数据包的时候, 将拥塞窗口和接收端主机反馈的窗口大小做比较, 取较小的值作为实际发送的窗口。提高传输的效率。</span>  
3、**面向字节流**：创建一个TCP的socket, 同时在内核中创建一个发送缓冲区和一个接收缓冲区；另一方面, TCP的一个连接, 既有发送缓冲区, 也有接收缓冲区, 那么对于这一个连接, 既可以读数据, 也可以写数据. 这个概念叫做全双工 。  

**协议**：HTTP、HTTPS、SSH、Telnet、FTP、SMTP

**TCP粘包问题**  
首先要明确, 粘包问题中的 “包” , 是指的应用层的数据包；  
在TCP的协议头中, 没有如同UDP一样的 “报文长度” 这样的字段, 但是有一个序号这样的字段；  
站在传输层的角度, TCP是一个一个报文过来的，按照序号排好序放在缓冲区中；  
站在应用层的角度, 看到的只是一串连续的字节数据. 那么应用程序看到了这么一连串的字节数据, 就不知道从哪个部分开始到哪个部分是一个完整的应用层数据包。  

解决：**明确两个包之间的边界**。  

1、对于定长的包, 保证每次都按固定大小读取即可;  
2、对于变长的包, 可以在报头的位置, 约定一个包总长度的字段, 从而就知道了包的结束位置;  
3、对于变长的包, 还可以在包和包之间使用明确的分隔符；  
4、TLV格式的数据传输。

**UDP特点：**

UDP数据报最大长度64K（包含UDP首部），如果数据长度超过64K就需要在应用层手动分包，UDP无法保证包序，需要在应用层进行编号。

1、**无连接**：知道对端的IP和端口号就直接进行传输, 不需要建立连接。  
2、**不可靠**：没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息。  
3、**面向数据报**：不能够灵活的控制读写数据的次数和数量，应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并。  
4、**数据收不够灵活**，但是能够明确区分两个数据包，避免粘包问题。

**协议**：  

NFS: 网络文件系统  
TFTP: 简单文件传输协议  
DHCP: 动态主机配置协议  
BOOTP: 启动协议(用于无盘设备启动)  
DNS: 域名解析协议

## Http和Https

HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

Https协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

**区别：**

1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。  
2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。  
3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。  
4、http的连接很简单，是无状态的；https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。  

HTTP特点：

1、**支持客户/服务器模式**。（C/S模式）  
2、**简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。  
3、**灵活**：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。  
4、**无连接**：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。  
5、**无状态**：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。  

Https特点：

1、相比于http，https可以提供更加优质保密的信息，**保证了用户数据的安全性**，此外https同时也**一定程度上保护了服务端**，使用恶意攻击和伪装数据的成本大大提高。  
2、HTTPS技术门槛较高, 同时加重了服务端的负担，相比于http其需要更多的资源来支撑，同时也降低了用户的访问速度。

**Https加密过程：**  
①认证服务器  
②协商会话秘钥  
③加密传输  

**SSL简介**：

安全套接字层（Secure Socket Layer）是为了弥补HTTP协议的一些缺陷而产生的一个协议层。

位置：HTTP - SSL - TCP

在SSL中应用了非对称加密和对称加密来实现密钥和报文的加密传输，同时可以进行身份验证的功能。  
1.首先应有一个可靠的第三方机构，负责将可信机构的公钥嵌入客户端浏览器中，服务器端将生成的公钥发送给可信机构，可信机构使用自己的私钥对其进行加密生成公钥证书，之后将证书发送给服务器端。  
2.客户端向服务端发送请求，服务器端使用加密好的公钥证书对返回报文进行加密，并传输给客户端。  
3.客户端浏览器用认证机构的公钥对证书进行检验，并获得公钥。 

## JDK1.8的特性

1、Lambda表达式  
2、函数式接口  
3、方法引用和构造器调用  
4、Stream API  
5、接口中的默认方法和静态方法  
6、时间日期API更新  

## &hearts;JVM加载机制

**基本必考的重点：JVM加载机制、虚拟机结构、双亲委派机制、垃圾回收算法对比**

请看详解: [Android进阶-JVM的内存分配](/android/JVM与DVM必知必会)

## 数据结构

数据结构是计算机存储、组织数据的方式，指数据元素相互之间存在一种或多种特定关系的集合。  
数据结构分类：线性结构和非线性结构。  
<span>线性结构指的是数据元素之间存在着“一对一”的线性关系。</span>

线性结构：**数组、链表、队列、栈**  
非线性结构：**多维数组、广义表、树结构、图结构**

详情请看：[数据结构与算法](/java/数据结构与算法.md)

### ArrayList数据结构

ArrayList的底层数据结构就是一个**数组**，数组元素的类型为Object类型，对ArrayList的所有操作底层都是基于数组的。  
ArrayList在多线程的环境下是不能保证具有[原子性](#多线程三个特性)的，因此ArrayList在多线程的环境下是线程不安全的。

|集合|数据结构|是否线程安全|插入、删除效率|获取、更新效率|
|---|---|---|---|---|
|ArrayList|数组|非线程安全|效率低(涉及数组的复制和移动)|效率高|
|Vector|数组|线程安全|效率最低(涉及数组的复制、移动及线程同步)|效率较高(synchronized同步方法修饰)|
|LinkedList|双向链表|非线程安全|效率高|效率低(需要全list遍历)|

### &hearts;HashMap数据结构

在JDK1.6，JDK1.7中，HashMap采用**数组+链表**实现，即使用链表处理冲突，同一hash值的元素都存储在一个链表里。（但是当位于一个桶中的元素较多时，通过key值依次查找的效率较低。）

而JDK1.8中，HashMap采用**数组+链表+红黑树**实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。

**HashMap的实现原理：**

首先有一个链表数组，当添加一个元素(key-value)时，会根据key的hash值和桶的数量来计算数组的下标，以确定插入数组中的位置，
插入相同key值的话就会覆盖之前的value值，如果不同的key值产生了相同的hash值的时候，也就是hash冲突，就会形成一个单向链表，将多个相同hash值的元素存储在链表中，
而当链表长度过长时（阈值8），链表就转换为红黑树，这样可以大大提高查找的效率。

数据结构：数组，单线链表，红黑树（1.8）

特点：快速存储，快速查找，可伸缩（当存储容量达到0.75的时候数组的长度就会变为原来的2倍）。

Hash算法：  
hash算法就是通过hashcode与自己进行向右位移16的异或运算。

为什么会有hash冲突？  
当存储的元素越来越多的时候，难免会出现不同的key产生相同的hash值的问题（位桶的长度发生改变），那么这个时候就会产生hash冲突，为了解决hash冲突，位桶就会产生一个单向链表，当单向链表长度超过8时就会变成红黑树。

**LinkedHashMap**  
LinkedHashMap继承自HashMap，因此，它具备了HashMap的优良特性，并在此基础上，LinkedHashMap又在内部增加了一个链表，用以存放元素的顺序。因此，LinkedHashMap可以简单理解为一个维护了元素次序表的HashMap。  
LinkedHashMap提供两种类型的顺序：一是元素插入时的顺序；二是最近访问的顺序。

**TreeMap**  
TreeMap可以简单理解为一种可以进行排序的Map实现。与LinkedHashMap不同，LinkedHashMap是根据元素增加或者访问的先后顺序进行排序，而TreeMap则根据元素的Key进行排序。

**HashMap和HashTable以及CurrentHashMap的区别？**

1、HashMap的KV均可为null，而HashTable的KV均不能为null。因此，不是使用get(key)判断HashMap是否存在某个键，而应该用containsKey(key)来判断某个键。  
2、HashMap是非synchronized，而HashTable则是synchronied（这也意味着同一时刻，只能有一个线程获取同步锁，对HashTable的值进行修改）。这意味着HashTable线程安全，而HashMap则不是线程安全的。  
3、HashMap的迭代器是fail-fast(快速失败)迭代器，而HashTable则是fail-safe（安全失败）迭代器。二者的主要区别在于遍历集合时，是否能同时修改集合的元素。  
4、HashMap和HashTable都是插入后扩容，因此有可能产生无效扩容（扩容后不再插入导致空间的浪费），且每次扩容，原来数组中的元素都要重新计算其存放的位置后重新插入。  

JDK5之后提供了ConcurrentHashMap来替代HashTable。ConcurrentHashMap是对HashTable的优化。

1、ConcurrentHashMap采用分段锁，线程安全。  
2、底层实现采用 分段数组+链表。  
3、HashTable进行修改操作时，要锁住整张表，以保证数据安全；而ConcurrentHashMap只需锁住要修改数据所在的那一分片（锁分离技术）。  
4、ConcurrentHashMap是段内插入前扩容，即插入前检查当前有效存储数组的hash值个数是否超过负载因子（默认为总容量的75%，可调参数），若超过，进行段内扩容。  

**分段锁技术**  

1、将数据分成若干段进行存储。  
2、为每一段分配一把锁。  
3、当线程需要对某一段进行增删改查时，需要先获取分段锁，再进行操作，操作完毕再释放。  

### HashSet数据结构

HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。

**HashSet实现原理**

对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，操作也基本上都是直接调用底层HashMap的相关方法来完成。

根据保存对象的equals和hashCode方法来确保唯一性。

LinkedHashSet,TreeSet都是对应的Map的一种封装。

## 数组和链表的区别

**链表**  

链表是一种上一个元素的引用指向下一个元素的存储结构，链表通过指针来连接元素与元素。  
链表就是将一系列不连续的内存联系起来，将那种碎片内存进行合理的利用，解决空间的问题。  
链表允许插入和删除表上任意位置上的节点，但是不允许随即存取。  
链表有很多种不同的类型：**单向链表、双向链表及循环链表**。

**数组和链表的区别：**  

不同：  
1、链表是链式的存储结构；数组是顺序的存储结构。  
2、链表通过**指针**来连接元素与元素，数组则是把所有元素**按次序依次存储。**  
3、链表的插入删除元素相对数组较为简单，不需要移动元素，且较为容易实现长度扩充，但是寻找某个元素较为困难。  
4、数组寻找某个元素较为简单，但插入与删除比较复杂，由于最大长度需要在编程一开始时指定，故当达到最大长度时，扩充长度不如链表方便。  

相同：  
两种结构均可实现数据的顺序存储，构造出来的模型呈线性结构。

## 二叉树、平衡二叉树、红黑树

二叉查找树的特点就是左子树的节点值比父亲节点小，而右子树的节点值比父亲节点大。可以采取类似于二分查找的思想，快速找到某个节点。  

二叉树的遍历有三种方式：  
（1）前序遍历（DLR），首先访问根结点，然后遍历左子树，最后遍历右子树。简记根-左-右。  
（2）中序遍历（LDR），首先遍历左子树，然后访问根结点，最后遍历右子树。简记左-根-右。  
（3）后序遍历（LRD），首先遍历左子树，然后遍历右子树，最后访问根结点。简记左-右-根。  

由于二叉查找树会存在一种极端的情况，近似退化成一个链表结构，二叉查找树的查找时间复杂度顿时变成了 O(n)。所以引进了平衡二叉树。

**平衡二叉树**具有二叉查找树的全部特性，**每个节点的左子树和右子树的高度差至多等于1**。

**为什么有了平衡树还需要红黑树？**

虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O(logn)，不过却不是最佳的，因为平衡树要求**每个节点的左子树和右子树的高度差至多等于1**，这个要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过**左旋**和**右旋**来进行调整，使之再次成为一颗符合要求的平衡树。

**红黑树：**  
1、具有二叉查找树的特点  
2、根节点是黑色的  
3、每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据  
4、任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的  
5、每个节点，从该节点到达其可达的叶子节点的所有路径，都包含相同数目的黑色节点  

正是由于红黑树的这种特点，使得它能够在最坏情况下，也能在 O(logn) 的时间复杂度查找到某个节点。  
不过，与平衡树不同的是，红黑树在插入、删除等操作，不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整，这也是我们为什么大多数情况下使用红黑树的原因。  
单单在查找方面的效率的话，平衡树比红黑树快。

**总结**，平衡树是为了解决二叉查找树退化为链表的情况，而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。

##  String、StringBuilder、StringBuffer

StringBuffer是线程安全的。  
StringBuilder是非线程安全。  
StringBuilder与StringBuffer的对象存储在堆中。String对象存储在Constant String Pool(字符串常量池)。  
StringBuffer和StringBuilder是可变对象。String一旦创建无法修改，并且String是线程安全的。
<span>安全和性能考虑(字符串常量池)是String类不可变的主要原因。</span>

## Java线程状态和各种锁的区别

**线程状态：**  
1、**初始(NEW)**：新创建了一个线程对象，但还没有调用start()方法。  
2、**运行(RUNNABLE)**：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。  
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。  
3、**阻塞(BLOCKED)**：表示线程阻塞于锁。  
4、**等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。  
5、**超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。  
6、**终止(TERMINATED)**：表示该线程已经执行完毕。  

**锁：**  
1、**公平锁/非公平锁**（公平锁是指多个线程按照申请锁的顺序来获取锁）  
2、**可重入锁**（又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁）  
3、**独享锁/共享锁**（独享锁是指该锁一次只能被一个线程所持有）  
4、**互斥锁/读写锁**（ReentrantLock/ReadWriteLock）  
5、**乐观锁/悲观锁**（悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。）   
6、**分段锁**（分段锁其实是一种锁的设计，并不是具体的一种锁）  
7、**偏向锁/轻量级锁/重量级锁**（这三种锁是指锁的状态，并且是针对Synchronized）  
8、**自旋锁**（自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU）

**sleep 、wait、yield 的区别，wait 的线程如何唤醒它？**

Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。  

obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。**依靠notify()、notifyAll()唤醒**或者wait(long timeout) **timeout时间到自动唤醒**。  

Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。该方法与sleep()类似，只是不能由用户指定暂停多长时间。  

## 多线程三个特性

**原子性**：是指一个操作是不可中断的。即使是多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。比如，对于一个静态全局变量int i，两个线程同时对它赋值，线程A给他赋值为1，线程B给他赋值为-1。那么不管这两个线程以何种方式。何种步调工作，i的值要么是1，要么是-1.线程A和线程B之间是没有干扰的。这就是原子性的一个特点，不可被中断。

**可见性**：是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。显然，对于串行来说，可见性问题是不存在的。

**有序性**：在并发时，程序的执行可能会出现乱序。给人的直观感觉就是：写在前面的代码，会在后面执行。有序性问题的原因是因为程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。

**join()方法的作用**  
join() 会让调用线程等待被调用线程结束后，才会继续执行。使用的场景为我们需要等待某个线程执行完成后才可继续执行的场景。

## Synchronized和volatile、ReentrantLock、CAS 

**Synchronized**  
Synchronized提供了同步锁的概念，被Synchronized修饰的代码段可以防止被多个线程同时执行，必须一个线程把Synchronized修饰的代码段都执行完毕了，其他的线程才能开始执行这段代码。 因为Synchronized保证了在同一时刻，只能有一个线程执行同步代码块，所以执行同步代码块的时候相当于是单线程操作了，那么线程的可见性、原子性、有序性（线程之间的执行顺序）它都能保证了。

**volatile**  
其实volatile关键字的作用就是保证了可见性和有序性（不保证[原子性](#多线程三个特性)），如果一个共享变量被volatile关键字修饰，那么如果一个线程修改了这个共享变量后，其他线程是立马可知的。  
volatile能禁止指令重新排序，在指令重排序优化时，在volatile变量之前的指令不能在volatile之后执行，在volatile之后的指令也不能在volatile之前执行，所以它保证了有序性。  

**ReentrantLock**  
ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。

**Synchronized和volatile的区别**  
volatile只能作用于变量，使用范围较小。synchronized可以用在方法、类、同步代码块等，使用范围比较广。  
volatile只能保证可见性和有序性，不能保证原子性。而可见性、有序性、原子性synchronized都可以保证。  
volatile不会造成线程阻塞。synchronized可能会造成线程阻塞。  

**Synchronized和ReentrantLock的区别**  
ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。  
ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。  
ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。  

**synchronized 修饰实例方法和修饰静态方法的区别**

synchronized修饰实例方法是对类的当前实例进行加锁，防止其他线程同时访问该类的该实例的所有synchronized块，注意这里是“类的当前实例”，类的两个不同实例就没有这种约束了。

synchronized修饰静态方法恰好就是要控制类的所有实例的访问了，static synchronized是限制线程同时访问jvm中该类的所有实例同时访问对应的代码块。

**实现原理**  
jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。

## 死锁产生条件，死锁应对策略

死锁发生的四个必要条件是：  
1.资源互斥使用。   
2.多个进程保持一定的资源，但又请求新的资源。   
3.资源不可被剥夺。   
4.多个进程循环等待。   

一般死锁的应对策略有：   
1.死锁预防。如进程需要的所有资源，在一开始就全部申请好得到之后再开始执行。   
2.死锁避免。如进程每次申请申请资源的时候，根据一定的算法，去看该请求可能不可能造成死锁，如果可能，就不给它分配该资源。   
3.死锁处理。破坏四个必要条件的其中一个，比如kill掉一个进程。   
4.死锁忽略。不管死锁，由用户自行处理，比如重启电脑。一般的系统其实都采取这种策略。  

## final、finally、finalize区别

**final**  
修饰类，方法，变量

**finally**  
finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下。

**finalize**  
finalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。

## 四大引用类型

从Java SE2开始，就提供了四种类型的引用：**强引用**、**软引用**、**弱引用**和**虚引用**。

Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。

| 类别 | 回收机制 | 用途 | 生存时间 |
| --- | --- | --- | --- |
| 强引用 | 从不回收 | 对象状态 | JVM停止运行时|
| 软引用 | 内存不足时回收 | 缓存 | 内存不足 |
| 弱引用 | 对象不被引用时回收 | 缓存 | GC运行后 |
| 虚引用 | 对象被回收时 | 管理控制精确内存稳定性 | unknown |

**一、强引用（StrongReference）**

一个对象若持有强引用，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。

①强引用可以直接访问目标对象。  
②强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象。  
③强引用可能导致内存泄露。

**二、软引用（SoftReference）**

如果一个对象持有软引用，那么如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。

①软引用可用来实现内存敏感的高速缓存。  
②通过软引用的get()方法，取得对象实例的强引用，GC在内存充足的情况下，不会回收软引用对象。  
③一旦GC回收Java对象之后，get()方法将返回null，在获取软引用对象的代码中需要判断是否为null。

**三、弱引用（WeakReference）**

如果一个对象持有弱引用，那么在垃圾回收器线程扫描的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

①只具有弱引用的对象拥有更短暂的生命周期，可能随时被回收。  
②只具有软引用的对象只有当内存不够的时候才被回收，在内存足够的时候，通常不被回收。

**四、虚引用（PhantomReference）**

虚引用是所有引用类型中最弱的一个。  
一个持有虚引用的对象，和没有引用几乎是一样的，随时都可能被垃圾回收器回收。当试图通过虚引用的get()方法取得强引用时，总是会失败。并且，虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。

## 数据类型

变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。  
内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。  
因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。  

Java 的两大数据类型：**内置数据类型**和**引用数据类型**。

**内置数据类型**  
Java语言提供了八种基本类型：  
六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。

四个整数型：  **byte &nbsp; &nbsp; short &nbsp; &nbsp; int &nbsp; &nbsp; long**  
两个浮点型：  **float &nbsp; &nbsp; double**   
一个布尔型：  **boolean**  
一个字符型：  **char**

**引用数据类型**  
引用类型指向一个对象，指向对象的变量是引用变量。
 
变量一旦声明后，类型就不能被改变了。  
1、对象、数组都是引用数据类型。  
2、所有引用类型的默认值都是null。  

## IO流

它是一种数据的流从源头流到目的地。  
比如文件拷贝，输入流和输出流都包括了。输入流从文件中读取数据存储到进程(process)中，输出流从进程中读取数据然后写入到目标文件。

1、按照数据流的方向不同可以分为：**输入流** 和 **输出流。**  

2、按照处理数据单位不同可以分为：**字节流** 和 **字符流。**  
字节流：一次读入或读出是8位二进制，后缀是Stream。  
字符流：一次读入或读出是16位二进制，后缀是Reader，Writer。  
<span>字符流能实现的功能字节流都能实现，反之不一定。如：图片，视频等二进制文件，只能使用字节流读写。</span>  

3、按照实现功能不同可以分为：**节点流** 和 **处理流。**  
节点流：直接与数据源相连，读入或读出。  
处理流：与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。  

![IO流](https://img.upyun.zzming.cn/android/io.png)

## 数据库事务

数据库中的事务了解吗？事务的四大特性？

数据库事务，事务是指一系列逻辑上不可分割的SQL语句，事务有四大特性（ACID）：原子性、一致性、隔离性、持久性。

**原子性**：操作后的点要跟预先的点相同，要么全部执行成功，要么就不执行。

**一致性**：事务完成时数据保持一致性，处于一种有意义的状态，就比如转账，A用户转钱给B用户，如果A的钱减少了，而B的的余额却没有增加，那么我们认为此时数据不一致。

**隔离性**：即保证每一个事务能够看到的数据总是一致的，事物可以并发执行但是互不干扰。

**持久性**：当一个事务提交后这个数据库状态就发生了改变，比如写数据写到一半死机了，重启后数据库会根据日志进行回滚，最终将全部数据写入。


数据库三大范式定义与理解：  
第一范式（1NF）：每一个分量必须是不可分的数据项。  
1、有主键，且主键不能为空。  
2、字段不能再分。

第二范式（2NF）：在范式一的基础上，且每一个非主属性完全函数依赖于主键。  
1、满足第一范式。  
2、表中的每一个非主属性，必须完全依赖于本表主键。  
3、只有当一个表中，主键由两个或以上的属性组成的时候，才会出现不符合第二范式的情况。  

第三范式（3NF）：在第二范式的基础上，且消除传递依赖性。  
1、满足第二范式。  
2、所有的非主键列依赖于主键列。  


