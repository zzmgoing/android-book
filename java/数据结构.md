# 数据结构

数据结构是计算机存储、组织数据的方式，指数据元素相互之间存在一种或多种特定关系的集合。  
数据结构分类：线性结构和非线性结构。  
<span>线性结构指的是数据元素之间存在着“一对一”的线性关系。</span>

线性结构：**数组、链表、队列、栈**  
非线性结构：**多维数组、广义表、树结构、图结构**

详情请看：[数据结构与算法](/java/数据结构与算法.md)

## ArrayList数据结构

ArrayList的底层数据结构就是一个**数组**，数组元素的类型为Object类型，对ArrayList的所有操作底层都是基于数组的。  
ArrayList在多线程的环境下是不能保证具有[原子性](/java/多线程三个特性.md)的，因此ArrayList在多线程的环境下是线程不安全的。

|集合|数据结构|是否线程安全|插入、删除效率|获取、更新效率|
|---|---|---|---|---|
|ArrayList|数组|非线程安全|效率低(涉及数组的复制和移动)|效率高|
|Vector|数组|线程安全|效率最低(涉及数组的复制、移动及线程同步)|效率较高(synchronized同步方法修饰)|
|LinkedList|双向链表|非线程安全|效率高|效率低(需要全list遍历)|

## HashMap数据结构

在JDK1.6，JDK1.7中，HashMap采用**数组+链表**实现，即使用链表处理冲突，同一hash值的元素都存储在一个链表里。（但是当位于一个桶中的元素较多时，通过key值依次查找的效率较低。）

而JDK1.8中，HashMap采用**数组+链表+红黑树**实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。

**HashMap的实现原理：**

首先有一个链表数组，当添加一个元素(key-value)时，会根据key的hash值和桶的数量来计算数组的下标，以确定插入数组中的位置，
插入相同key值的话就会覆盖之前的value值，如果不同的key值产生了相同的hash值的时候，也就是hash冲突，就会形成一个单向链表，将多个相同hash值的元素存储在链表中，
而当链表长度过长时（阈值8），链表就转换为红黑树，这样可以大大提高查找的效率。

数据结构：数组，单线链表，红黑树（1.8）

特点：快速存储，快速查找，可伸缩（当存储容量达到0.75的时候数组的长度就会变为原来的2倍）。

Hash算法：  
hash算法就是通过hashcode与自己进行向右位移16的异或运算。

为什么会有hash冲突？  
当存储的元素越来越多的时候，难免会出现不同的key产生相同的hash值的问题（位桶的长度发生改变），那么这个时候就会产生hash冲突，为了解决hash冲突，位桶就会产生一个单向链表，当单向链表长度超过8时就会变成红黑树。

**LinkedHashMap**  
LinkedHashMap继承自HashMap，因此，它具备了HashMap的优良特性，并在此基础上，LinkedHashMap又在内部增加了一个链表，用以存放元素的顺序。因此，LinkedHashMap可以简单理解为一个维护了元素次序表的HashMap。  
LinkedHashMap提供两种类型的顺序：一是元素插入时的顺序；二是最近访问的顺序。

**TreeMap**  
TreeMap可以简单理解为一种可以进行排序的Map实现。与LinkedHashMap不同，LinkedHashMap是根据元素增加或者访问的先后顺序进行排序，而TreeMap则根据元素的Key进行排序。

**HashMap和HashTable以及CurrentHashMap的区别？**

1、HashMap的KV均可为null，而HashTable的KV均不能为null。因此，不是使用get(key)判断HashMap是否存在某个键，而应该用containsKey(key)来判断某个键。  
2、HashMap是非synchronized，而HashTable则是synchronied（这也意味着同一时刻，只能有一个线程获取同步锁，对HashTable的值进行修改）。这意味着HashTable线程安全，而HashMap则不是线程安全的。  
3、HashMap的迭代器是fail-fast(快速失败)迭代器，而HashTable则是fail-safe（安全失败）迭代器。二者的主要区别在于遍历集合时，是否能同时修改集合的元素。  
4、HashMap和HashTable都是插入后扩容，因此有可能产生无效扩容（扩容后不再插入导致空间的浪费），且每次扩容，原来数组中的元素都要重新计算其存放的位置后重新插入。  

JDK5之后提供了ConcurrentHashMap来替代HashTable。ConcurrentHashMap是对HashTable的优化。

1、ConcurrentHashMap采用分段锁，线程安全。  
2、底层实现采用 分段数组+链表。  
3、HashTable进行修改操作时，要锁住整张表，以保证数据安全；而ConcurrentHashMap只需锁住要修改数据所在的那一分片（锁分离技术）。  
4、ConcurrentHashMap是段内插入前扩容，即插入前检查当前有效存储数组的hash值个数是否超过负载因子（默认为总容量的75%，可调参数），若超过，进行段内扩容。  

**分段锁技术**  

1、将数据分成若干段进行存储。  
2、为每一段分配一把锁。  
3、当线程需要对某一段进行增删改查时，需要先获取分段锁，再进行操作，操作完毕再释放。  

## HashSet数据结构

HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。

**HashSet实现原理**

对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，操作也基本上都是直接调用底层HashMap的相关方法来完成。

根据保存对象的equals和hashCode方法来确保唯一性。

LinkedHashSet,TreeSet都是对应的Map的一种封装。