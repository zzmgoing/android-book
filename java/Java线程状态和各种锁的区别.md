# Java线程状态和各种锁的区别

**线程状态：**  
1、**初始(NEW)**：新创建了一个线程对象，但还没有调用start()方法。  
2、**运行(RUNNABLE)**：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。  
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。  
3、**阻塞(BLOCKED)**：表示线程阻塞于锁。  
4、**等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。  
5、**超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。  
6、**终止(TERMINATED)**：表示该线程已经执行完毕。  

**锁：**  
1、**公平锁/非公平锁**（公平锁是指多个线程按照申请锁的顺序来获取锁）  
2、**可重入锁**（又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁）  
3、**独享锁/共享锁**（独享锁是指该锁一次只能被一个线程所持有）  
4、**互斥锁/读写锁**（ReentrantLock/ReadWriteLock）  
5、**乐观锁/悲观锁**（悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。）   
6、**分段锁**（分段锁其实是一种锁的设计，并不是具体的一种锁）  
7、**偏向锁/轻量级锁/重量级锁**（这三种锁是指锁的状态，并且是针对Synchronized）  
8、**自旋锁**（自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU）

**sleep 、wait、yield 的区别，wait 的线程如何唤醒它？**

Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。  

obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。**依靠notify()、notifyAll()唤醒**或者wait(long timeout) **timeout时间到自动唤醒**。  

Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。该方法与sleep()类似，只是不能由用户指定暂停多长时间。  
