# APT和AOP

## APT

总所周知，ButterKnife、Dagger、GreenDao、Protocol Buffers 这些常用的注解生成框架都会在编译过程中生成代码。而 这种使用 AndroidAnnotation 结合 APT 技术 来生成代码的时机，是在编译最开始的时候介入的。而 AOP 是在编译完成后生成 dex 文件之前的时候，直接通过修改 .class 文件的方式，来直接添加或者修改代码逻辑的。

使用 APT 技术生成 Java 代码的方式具有如下 两方面 的优势：

1）、隔离了框架复杂的内部实现，使得开发更加地简单高效。  
2）、大大减少了手工重复的工作量，降低了开发时出错的机率。

## AOP

而对于操作字节码的方式来说，一般都在 代码监控、代码修改、代码分析 这三个场景有着很广泛的应用。

相对于 Java 代码生成的方式，操作字节码的方式有如下 特点：

1）、应用场景更广。  
2）、功能更加强大。  
3）、使用复杂度较高。  
此外，我们不仅可以操作 .class 文件的 Java 字节码，也可以操作 .dex 文件的 Dalvik 字节码。

**1、代码监控**

编译插桩技术除了 不能够实现耗电监控，它能够实现各式各样的性能监控，例如：网络数据监控、耗时方法监控、大图监控、线程监控 等等。

譬如 网络数据监控 的实现，就是在 网络层通过 hook 网络库方法 和 自动化注入拦截器的形式，实现网络请求的全过程监控，包括获取握手时长，首包时间，DNS 耗时，网络耗时等各个网络阶段的信息。

实现了对网络请求过程的监控之后，我们便可以 对整个网络过程的数据表现进行详细地分析，找到网络层面性能的问题点，并做出针对性地优化措施。例如针对于 网络错误率偏高 的问题，我们可以采取以下几方面的措施，如下所示：

1）、使用 HttpDNS。  
2）、将错误数据同步 CDN。  
3）、CDN 调度链路优化。  

**2、代码修改**

用编译插桩技术来实现代码修改的场景非常之多，而使用最为频繁的场景具体可细分为为如下四种：

1）、实现无痕埋点：如网易HubbleData之Android无埋点实践、51 信用卡 Android 自动埋点实践。  
2）、统一处理点击抖动：编译阶段统一 hook android.view.View.OnClickListener#onClick() 方法，来实现一个快速点击无效的防抖动效果，这样便能高效、无侵入性地统一解决客户端快速点击多次导致频繁响应的问题。  
3）、第三方 SDK 的容灾处理：我们可以在上线前临时修改或者 hook 第三方 SDK 的方法，做到快速容灾上线。  
4）、实现热修复框架：我们可以在 Gradle 进行自动化构建的时候，即在 Java 源码编译完成之后，生成 dex 文件之前进行插桩，而插桩的作用是在每个方法执行时先去根据自己方法的签名寻找是否有自己对应的 patch 方法，如果有，执行 patch 方法；如果没有，则执行自己原有的逻辑。  

**3、代码分析**

例如 Findbugs 等三方的代码检查工具里面的 自定义代码检查 也使用了编译插桩技术，利用它我们可以找出 不合理的 Hanlder 使用、new Thread 调用、敏感权限调用 等等一系列编码问题。

## ASM

ASM 是一款读写Java字节码的工具，可以达到跳过源码编写，编译，直接以字节码的形式创建类，修改已经存在类(或者jar中的class)的属性，方法等。

- ClassWriter（生成类），visitMethod、visitField创建方法、成员变量等。
- ClassReader（修改类），调用accept方法传入ClassVisitor和ClassWriter对象进行访问类并修改。
- MethodVisitor（方法注入），一般使用较多。

## Hook技术原理

Hook 的选择点：  
静态变量和单例，因为一旦创建对象，它们不容易变化，非常容易定位。

Hook 过程：  
1、寻找 Hook 点，原则是静态变量或者单例对象，尽量 Hook public 的对象和方法。  
2、选择合适的代理方式，如果是接口可以用动态代理。  
3、偷梁换柱——用代理对象替换原始对象。

### 代理模式

代理模式定义：为其他对象提供一种代理以控制这个对象的访问

#### 静态代理

定义一个代理类，构造函数接收被代理的类，然后替换。

#### 动态代理

- 定义代理对象和真实对象的公共接口；（与静态代理步骤相同）
- 真实对象实现公共接口中的方法；（与静态代理步骤相同）
- 定义一个实现了InvocationHandler接口的动态代理类；
- 通过Proxy类的newProxyInstance方法创建代理对象，调用代理对象的方法。

使用Proxy这个类的 newProxyInstance 这个方法

```java
public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
```

JDK动态代理需要借助接口来实现，如果我们要代理的对象功能没有抽成任何接口，那么我们就无法通过JDK动态代理的方式来实现。

- loader：一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载
- interfaces：一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了
- 一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上。

与静态代理相比，动态代理具有如下的优点：

- 代理转发的过程自动化了，实现自动化搬砖；
- 代理类的代码逻辑和具体业务逻辑解耦，与业务无关；

>[https://blog.csdn.net/qq_20798591/article/details/105261549](https://blog.csdn.net/qq_20798591/article/details/105261549)