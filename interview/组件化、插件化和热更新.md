# 组件化、插件化和热更新

## 组件化

当一个项目中业务种类较多，需求更新迭代快时，单一的工程中业务模块耦合度太高，牵一发而动全身，
修改一个地方都要编译整个工程，协同开发易产生较多的冲突，无法专注于单一功能点，影响开发效率等。

组件化便是将不同的业务功能进行拆分，分成相对独立的模块，每个模块只包含与之功能相关的内容。
每个模块都是一个Module，在打包的时候它的身份是library，属于工程的一个依赖模块。在开发调试的时候它的身份是application，
可以单独运行，提高开发和测试效率。

**好处**

1、加快业务迭代速度，各个业务模块组件更加独立，不再出现业务耦合情况；  
2、稳定的公共模块采用依赖库方式，提供给各个业务线使用，减少重复开发和维护工作量；  
3、迭代频繁的业务模块采用组件方式，各业务研发可以互不干扰、提升协作效率，并控制产品质量；  
4、为新业务随时集成提供了基础，所有业务可上可下，灵活多变；  
5、降低团队成员熟悉项目的成本，降低项目的维护难度；  
6、加快编译速度，提高开发效率；  
7、控制代码权限，将代码的权限细分到更小的粒度；  

## 插件化

在程序运行时把插件apk直接加载到classloader里面的动态加载技术。

1、插件化的单位是apk(一个完整的应用)。  
2、插件化实现的也是解耦与加快编译，同时实现热插拔也就是热更新。  
3、插件化的灵活性在于是加载apk, 完全可以动态下载，动态更新，比组件化更灵活。  

**通信方式**

组件化的通信方式，按理说可以划分为多种，主流的是隐式和路由。隐式的存在使解耦与灵活大大降低，因此路由是主流（如ARouter、DRouter）。

插件化的通信方式，不同插件本身就是不同的进程了，因此通信方式偏向于Binder机制类似的进程间通信。

## 热更新原理

Android热更新技术是以ClassLoader类加载为基础的。  
在应用程序运行时去修改PathClassLoader.pathList.dexElements，将热更新的dex加载进去。

1、通过构造一个DexClassLoader对象来加载我们的热更新dex文件；  
2、通过反射获取系统默认的PathClassLoader.pathList.dexElements；  
3、将我们的热更新dex与系统默认的Elements数组合并，同时保证热更新dex在系统默认Elements数组之前；  
4、将合并完成后的数组设置回PathClassLoader.pathList.dexElements。

**热更新框架**

**Tinker**

Tinker 的方案，都是让 Classloader 去加载新的类。如果不重启，原来的类还在虚拟机中，就无法加载新类。因此，只有在下次重启的时候，在还没走到业务逻辑之前抢先加载补丁中的新类，这样后续访问这个类时，就会 Resolve 为新的类。从而达到热修复的目的。

Tinker 开发团队人员自研了 DexDiff 算法。 BsDiff 加载 so 和部分资源文件，DexDiff 加载 Dex文件，以达到性能最优。但是这个方案也有缺点，就是占用 ROM 较大。

**AndFix**

AndFix采用的是替换ArtMethod结构体中的字段，这样会有兼容问题，因为厂商可能会修改ArtMethod结构体，导致方法替换失败。Sophix采用的是替换整个ArtMethod结构体，这样不会存在兼容问题。

底层替换方案直接替换了方法，可以立即生效不需要重启。采用底层替换方案主要是阿里系为主，包括AndFix、Dexposed、阿里百川、Sophix。**Sophix是AndroidFix的升级方案**，目前可以集成阿里的SDK来实现。


> [Android组件化与插件化的差别在哪里，该怎么选型？](https://blog.csdn.net/aiyoufang/article/details/102947942)