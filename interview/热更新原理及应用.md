# 热更新原理及应用

Android热更新技术是以ClassLoader类加载为基础的。  
在应用程序运行时去修改PathClassLoader.pathList.dexElements，将热更新的dex加载进去。

1、通过构造一个DexClassLoader对象来加载我们的热更新dex文件；  
2、通过反射获取系统默认的PathClassLoader.pathList.dexElements；  
3、将我们的热更新dex与系统默认的Elements数组合并，同时保证热更新dex在系统默认Elements数组之前；  
4、将合并完成后的数组设置回PathClassLoader.pathList.dexElements。  

**热更新框架**

**Tinker**

Tinker 的方案，都是让 Classloader 去加载新的类。如果不重启，原来的类还在虚拟机中，就无法加载新类。因此，只有在下次重启的时候，在还没走到业务逻辑之前抢先加载补丁中的新类，这样后续访问这个类时，就会 Resolve 为新的类。从而达到热修复的目的。

Tinker 开发团队人员自研了 DexDiff 算法。 BsDiff 加载 so 和部分资源文件，DexDiff 加载 Dex文件，以达到性能最优。但是这个方案也有缺点，就是占用 ROM 较大。

**AndFix**

AndFix采用的是替换ArtMethod结构体中的字段，这样会有兼容问题，因为厂商可能会修改ArtMethod结构体，导致方法替换失败。Sophix采用的是替换整个ArtMethod结构体，这样不会存在兼容问题。

底层替换方案直接替换了方法，可以立即生效不需要重启。采用底层替换方案主要是阿里系为主，包括AndFix、Dexposed、阿里百川、Sophix。**Sophix是AndroidFix的升级方案**，目前可以集成阿里的SDK来实现。


> [Android热更新实现原理浅析](https://www.jianshu.com/p/8dcf750acdfe)