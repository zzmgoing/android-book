# 数组

## 1、找出数组中重复的数字

> 题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

<span>练习地址：[https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8)</span>

```java
public class Solution {
    // Parameters:
    //    numbers:     an array of integers
    //    length:      the length of array numbers
    //    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;
    //                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++
    //    这里要特别注意~返回任意重复的一个，赋值duplication[0]
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
    public boolean duplicate(int numbers[], int length, int [] duplication) {
        if (numbers == null || length <= 0) {
            return false;
        }
        for (int i = 0; i < length; i++) {
            if (numbers[i] < 0 || numbers[i] > length - 1) {
                return false;
            }
            while (numbers[i] != i) {
                if (numbers[numbers[i]] == numbers[i]) {
                    duplication[0] = numbers[i];
                    return true;
                } else {
                    int temp = numbers[i];
                    numbers[i] = numbers[temp];
                    numbers[temp] = temp;
                }
            }
        }
        return false;
    }

    /**
    * 不修改数组找出重复的数字
    * 在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。
    * 请找出数组中任意一个重复的数字，但不能修改输入的数组。
    * 例如，如果输入长度为8的数组{2,3,5,4,3,2,6,7}，那么对应的输出是重复的数字2或者3。
    **/
    public int getDuplication(int[] numbers, int length) {
        if (numbers == null || length <= 0) {
            return -1;
        }
        int start = 1, end = length - 1, mid;
        while (start <= end) {
            mid = (start + end) / 2;
            int count = countRange(numbers, start, mid);
            if (start == end) {
                if (count > 1) {
                    return start;
                } else {
                    return -1;
                }
            }
            if (count > mid - start + 1) {
                end = mid;
            } else {
                start = mid + 1;
            }
        }
        return -1;
    }

    private int countRange(int[] numbers, int low, int high) {
        int count = 0;
        for (int number : numbers) {
            if (number >= low && number <= high) {
                count++;
            }
        }
        return count;
    }
}
```

## 2、二维数组中查找整数

> 题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

<span>练习地址：[https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e)</span>

```java
public class Solution {
    public boolean Find(int target, int [][] array) {
        if (array == null || array.length == 0 || array[0] == null || array[0].length == 0) {
            return false;
        }
        int row = 0, column = array[0].length - 1;
        while (row < array.length && column >= 0) {
            if (array[row][column] == target) {
                return true;
            } else if (array[row][column] > target) {
                column--;
            } else {
                row++;
            }
        }
        return false;
    }
}
```

## 3、斐波那契数列第n项

> 题目一：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。

<span>练习地址：[https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3](https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3)</span>

```java
//递归
public class Solution {
    public int Fibonacci(int n) {
        if (n <= 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        return Fibonacci(n - 1) + Fibonacci(n - 2);
    }
}
//循环
public class Solution {
    public int Fibonacci(int n) {
        if (n <= 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        int last = 0, result = 1;
        for (int i = 2; i <= n; i++) {
            result += last;
            last = result - last;
        }
        return result;
    }
}
```

> 题目二：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

<span>练习地址：[https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4)</span>

```java
public class Solution {
    public int JumpFloor(int target) {
        if(target <= 0){
            return 0;
        }
        if(target == 1){
            return 1;
        }else if(target == 2){
            return 2;
        }else{
            return JumpFloor(target-1) + JumpFloor(target-2);
        }
    }
}
```

## 4、旋转数组的最小数字

> 题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
  
<span>练习地址：[https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba)</span>

```java
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if (array == null || array.length == 0) {
            return 0;
        }
        int start = 0, end = array.length - 1, mid;
        while (array[start] >= array[end]) {
            if (start + 1 == end) {
                return array[end];
            }
            mid = (start + end) / 2;
            if (array[start] == array[mid] && array[end] == array[mid]) {
                return minNumberInOrder(array, start, end);
            }
            if (array[mid] >= array[start]) {
                start = mid;
            } else if (array[mid] <= array[end]) {
                end = mid;
            }
        }
        return array[0];
    }
    
    private int minNumberInOrder(int[] array, int start, int end) {
        int min = array[start];
        for (int i = start + 1; i <= end; i++) {
            if (array[i] < min) {
                min = array[i];
            }
        }
        return min;
    }
}
```

## 5、矩阵中的路径

> 题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。

<span>练习地址：[https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc](https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc)</span>

```java
//回溯法
public class Solution {
    public boolean hasPath(char[] matrix, int rows, int cols, char[] str) {
        if (matrix == null || rows < 1 || cols < 1 || str == null) {
            return false;
        }
        boolean[][] visited = new boolean[rows][cols];
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                if (hasPath(matrix, rows, cols, row, col, str, 0, visited)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    private boolean hasPath(char[] matrix, int rows, int cols, int row, int col
                            , char[] str, int index, boolean[][] visited) {
        if (index == str.length) {
            return true;
        }
        if (row >= 0 && row < rows && col >= 0 && col < cols && !visited[row][col]
            && matrix[cols * row + col] == str[index]) {
            visited[row][col] = true;
            if (hasPath(matrix, rows, cols, row - 1, col, str, index + 1, visited)
               || hasPath(matrix, rows, cols, row + 1, col, str, index + 1, visited)
               || hasPath(matrix, rows, cols, row, col - 1, str, index + 1, visited)
               || hasPath(matrix, rows, cols, row, col + 1, str, index + 1, visited)) {
                return true;
            }
            visited[row][col] = false;
        }
        return false;
    }
}
```

## 6、机器人的运动范围

> 题目：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？
  
<span>练习地址：[https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8](https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8)</span>

```java
//回溯法
public class Solution {
    public int movingCount(int threshold, int rows, int cols) {
        if (threshold < 1 || rows < 1 || cols < 1) {
            return 0;
        }
        boolean[][] visited = new boolean[rows][cols];
        return movingCount(threshold, rows, cols, 0, 0, visited);
    }
    
    private int movingCount(int threshold, int rows, int cols, int row, int col, boolean[][] visited) {
        int count = 0;
        if (row >= 0 && row < rows && col >= 0 && col < cols && !visited[row][col]
            && sum(row) + sum(col) <= threshold) {
            visited[row][col] = true;
            count = 1 + movingCount(threshold, rows, cols, row - 1, col, visited)
                + movingCount(threshold, rows, cols, row + 1, col, visited)
                + movingCount(threshold, rows, cols, row, col + 1, visited)
                + movingCount(threshold, rows, cols, row, col - 1, visited);
        }
        return count;
    }
    
    private int sum(int number) {
        int sum = 0;
        while (number > 0) {
            sum += number % 10;
            number /= 10;
        }
        return sum;
    }
}
```

















> [剑指Offer Java版官方题解汇总](https://www.jianshu.com/p/4a889d052127)