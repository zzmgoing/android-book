# 二叉树

## 1、重建二叉树

> 题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
  
<span>练习地址：[https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6)</span>

```java
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode reConstructBinaryTree(int[] pre, int[] in) {
        if (pre == null || pre.length == 0 || in == null || in.length == 0 || pre.length != in.length) {
            return null;
        }
        return construct(pre, in, 0, pre.length - 1, 0, in.length - 1);
    }
    
    private TreeNode construct(int[] pre, int[] in, int preStart, int preEnd, int inStart, int inEnd) {
        if (preStart > preEnd || inStart > inEnd) {
            return null;
        }
        TreeNode node = new TreeNode(pre[preStart]);
        int inMid = inStart;
        while (in[inMid] != pre[preStart]) {
            inMid++;
        }
        int delta = inMid - inStart;
        node.left = construct(pre, in, preStart + 1, preStart + delta, inStart, inMid - 1);
        node.right = construct(pre, in, preStart + delta + 1, preEnd, inMid + 1, inEnd);
        return node;
    }
}
```

## 2、二叉树的下一个节点

> 题目：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

<span>练习地址：[https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e)</span>

```java
/*
public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        if (pNode == null) {
            return null;
        }
        if (pNode.right == null) {
            for (; pNode.next != null && pNode.next.right == pNode; pNode = pNode.next);
            return pNode.next;
        }
        for (pNode = pNode.right; pNode.left != null; pNode = pNode.left);
        return pNode;
    }
}
```
















> [剑指Offer Java版官方题解汇总](https://www.jianshu.com/p/4a889d052127)