# 开源框架

## OKHttp

> OkHttp是一个高性能的http请求库，它通过okio来进行流的读取和写入，定义了一些基础的io操作方法。然后将请求和回调封装成request和response，通过拦截器来处理各种请求，并返回结果。  

首先通过OkhttpClient创建Call发起同步或异步请求，OkHttp会通过dispatcher对我们所有的realcall进行统一管理，并通过execute()或enqueue()方法对请求进行处理，这两个方法最终会调用`RealCall`中`getResponseWithInterceptorChain()`方法，从拦截器中获取返回结果。

**OKHttp有哪些拦截器，分别起什么作用？**

OkHttp的拦截器是把所有的拦截器放到一个list里，然后每次依次执行拦截器，并且每个拦截器分为三部分：

- 预处理拦截器内容
- 通过*proceed*方法把请求交给下一个拦截器
- 下一个拦截器处理完成并返回，后续处理工作

这样依次下去就形成了一个链式调用，看看源码，具体有哪些拦截器：

```java
Response getResponseWithInterceptorChain() throws IOException {
    // Build a full stack of interceptors.
    List<Interceptor> interceptors = new ArrayList<>();
    interceptors.addAll(client.interceptors());
    interceptors.add(retryAndFollowUpInterceptor);
    interceptors.add(new BridgeInterceptor(client.cookieJar()));
    interceptors.add(new CacheInterceptor(client.internalCache()));
    interceptors.add(new ConnectInterceptor(client));
    if (!forWebSocket) {
      interceptors.addAll(client.networkInterceptors());
    }
    interceptors.add(new CallServerInterceptor(forWebSocket));

    Interceptor.Chain chain = new RealInterceptorChain(
        interceptors, null, null, null, 0, originalRequest);
    return chain.proceed(originalRequest);
  }
```

根据源码可知，一共**七**个拦截器：

|拦截器|描述|作用|
|--|--|--|
|**addInterceptor**|这是由开发者设置的，会按照开发者的要求，在所有的拦截器处理之前进行最早的拦截处理，比如一些公共参数，Header都可以在这里添加|开发者自定义|
|**RetryAndFollowUpInterceptor**|这里会对连接做一些初始化工作，以及请求失败的充实工作，重定向的后续请求工作，跟它的名字一样，就是做重试工作还有一些连接跟踪工作|重试拦截器，处理重定向|
|**BridgeInterceptor**|这里会为用户构建一个能够进行网络访问的请求，同时后续工作将网络请求回来的响应Response转化为用户可用的Response，比如添加文件类型，content-length计算添加，gzip解包等|基础的拦截器（设置请求头Cookie、Connection、Content-Type等，做一些返回的处理，保存Cookie等）|
|**CacheInterceptor**|这里主要是处理cache相关，会根据OkHttpClient对象的配置以及缓存策略对请求值进行缓存，而且如果本地有了可⽤的Cache，就可以在没有网络交互的情况下就返回缓存结果|缓存拦截器（在缓存可用的情况下，读取本地的缓存的数据）|
|**ConnectInterceptor**|这里主要就是负责建立连接了，会建立TCP连接或者TLS连接，以及负责编码解码的HttpCodec|连接的拦截器（调用`findHealthyConnection()`找到一个连接，首先判断有没有健康的，没有就创建（建立socket，握手连接），连接缓存）|
|**networkInterceptors**|这里也是开发者自己设置的，所以本质上和第一个拦截器差不多，但是由于位置不同，所以用处也不同。这个位置添加的拦截器可以看到请求和响应的数据了，所以可以做一些网络调试|开发者自定义|
|**CallServerInterceptor**|这里就是进行网络数据的请求和响应了，也就是实际的网络I/O操作，通过socket读写数据|给服务器写数据和读取数据；写头部信息，写body表单信息等等|

**OkHttp里面用到了什么设计模式？**

- **责任链模式**  
这个不要太明显，可以说是okhttp的精髓所在了，主要体现就是拦截器的使用，具体代码可以看看上述的拦截器介绍。
- **建造者模式**  
在Okhttp中，建造者模式也是用的挺多的，主要用处是将对象的创建与表示相分离，用Builder组装各项配置，比如Request。
- **工厂模式**  
工厂模式和建造者模式类似，区别就在于工厂模式侧重点在于对象的生成过程，而建造者模式主要是侧重对象的各个参数配置。例子有CacheInterceptor拦截器中有个CacheStrategy对象。
- **单例模式**

**OKHttp的Keep-Alive保活机制？**

> 当一个http请求完成后，tcp连接不会立即释放，如果有新的http请求，并且host和上次一样，那么可以复用tcp连接，省去重新连接的过程。

连接复用的3个核心类：
- **ConnectionPool**：保存了连接，管理连接；
- **RealConnection**：建立连接的一个对象，维护allocations列表；
- **StreamAllocation**：连接的一些封装。

## Retrofit

> Retrofit是基于OkHttp封装的一套网络请求框架。

1、通过注解简化代码  
2、支持自己更换解析的方式，搭配各式的converter来实现  
3、restful的api设计风格  
4、支持RxJava  

Retrofit在OkHttp上做了哪些封装？动态代理和静态代理的区别，是怎么实现的。

在Retrofit中使用到了动态代理，使用动态代理，可以无侵入式的扩展代码，在不改动原有代码的情况下，增强一些方法或功能，它的定义是：在程序运行时创建的代理方式。

## RxJava

> RxJava是一个基于事件流、实现异步操作的库。

RxJava原理：基于一种扩展的观察者模式，整个模式中有4个角色：  

|角色|作用|
|---|---|
|被观察者（Observable）|产生事件|
|观察者（Observer）|接收事件，并给出响应动作|	
|订阅（Subscribe）|连接 被观察者 & 观察者|
|事件（Event）|被观察者 & 观察者 沟通的载体|

被观察者 （Observable） 通过 订阅（Subscribe） 按顺序发送事件 给观察者 （Observer）  
观察者（Observer） 按顺序接收事件 & 作出对应的响应动作

**线程切换原理**：

```
...
.subscribeOn(Schedulers.newThread())
.subscribeOn(Schedulers.io())
.observeOn(AndroidSchedulers.mainThread())
```

subscribeOn()决定最原始数据源发射数据代码运行的线程，而接下来的发射数据代码是由observeOn决定的。  
observeOn()决定下游代码运行的线程，不定义的话是默认使用当前运行的线程。  

1、如果设置了observeOn(指定线程)，那么Observer（观察者）中的onNext()、onComplete()等方法将会运行在这个指定线程中去。subscribeOn()设置的线程不会影响到observeOn()。

2、如果设置了subscribeOn(指定线程)，那么Observable（被观察者）中subscribe()方法将会运行在这个指定线程中去。

RxJava分配线程时是通过调用链自下而上处理，所以最上面的subscribeOn()会覆盖下面的定义，也就是说subscribeOn()在调用链中最多定义一次就可以，位置任意。

**底层线程实现原理**：  

在IoScheduler中创建和缓存一组线程池并在可以重用时使用它们，主要是通过CachedWorkerPool将ThreadWorker用队列缓存起来，ThreadWorker继承NewThreadWorker，NewThreadWorker通过Executors来创建线程池。

# ARouter

ARouter会在项目的编译期通过注解处理器扫描所有添加@Route注解的Activity类，然后将Route注解中的path地址和Activity.class文件映射关系保存到它自己生成的java文件中。  

首先，我们了解下ARouter是干嘛的？ARouter是阿里巴巴研发的一个用于解决组件间，模块间界面跳转问题的框架。所以简单的说，就是用来跳转界面的，不同于平时用到的显式或隐式跳转，只需要在对应的界面上添加注解，就可以实现跳转，看个案例：

```java
@Route(path = "/test/activity")
public class YourActivity extend Activity {
    ...
}

//跳转
ARouter.getInstance().build("/test/activity").navigation();
```

使用很方便，通过一个path就可以进行跳转了，那么原理是什么呢？

其实仔细思考下，就可以联想到，既然关键跳转过程是通过path跳转到具体的activity，那么原理无非就是把path和Activity一一对应起来就行了。没错，其实就是通过注释，通过apt技术，也就是注解处理工具，把path和activity关联起来了。主要有以下几个步骤：

- 代码里加入的@Route注解，会在编译时期通过apt生成一些存储path和activity.class映射关系的类文件  
- app进程启动的时候会加载这些类文件，把保存这些映射关系的数据读到内存里(保存在map里)  
- 进行路由跳转的时候，通过build()方法传入要到达页面的路由地址，ARouter会通过它自己存储的路由表找到路由地址对应的Activity.class  
- 然后new Intent方法，如果有调用ARouter的withString()方法，就会调用intent.putExtra(String name, String value)方法添加参数  
- 最后调用navigation()方法，它的内部会调用startActivity(intent)进行跳转  

**ARouter怎么实现页面拦截**

<details><summary>拦截器的案例，用作页面跳转时候检验是否登录，然后判断跳转到登录页面还是目标页面</summary>

```java
@Interceptor(name = "login", priority = 6)
public class LoginInterceptorImpl implements IInterceptor {
    @Override
    public void process(Postcard postcard, InterceptorCallback callback) {
        String path = postcard.getPath();
        boolean isLogin = SPUtils.getInstance().getBoolean(ConfigConstants.SP_IS_LOGIN, false);

        if (isLogin) { 
            // 如果已经登录不拦截
            callback.onContinue(postcard);
        } else {  
            // 如果没有登录，进行拦截
            callback.onInterrupt(postcard);
        }

    }

    @Override
    public void init(Context context) {
        LogUtils.v("初始化成功"); 
    }

}

//使用
ARouter.getInstance().build(ConfigConstants.SECOND_PATH)
                         .withString("msg", "123")
                          .navigation(this,new LoginNavigationCallbackImpl()); 
                          // 第二个参数是路由跳转的回调


// 拦截的回调
public class LoginNavigationCallbackImpl  implements NavigationCallback{
    @Override 
    public void onFound(Postcard postcard) {

    }

    @Override 
    public void onLost(Postcard postcard) {

    }

    @Override   
    public void onArrival(Postcard postcard) {

    }

    @Override
    public void onInterrupt(Postcard postcard) {
     //拦截并跳转到登录页
        String path = postcard.getPath();
        Bundle bundle = postcard.getExtras();
        ARouter.getInstance().build(ConfigConstants.LOGIN_PATH)
                .with(bundle)
                .withString(ConfigConstants.PATH, path)
                .navigation();
    }
}
```

</details>

拦截器实现IInterceptor接口，使用注解@Interceptor，这个拦截器就会自动被注册了，同样是使用APT技术自动生成映射关系类。这里还有一个优先级参数priority，数值越小，就会越先执行。
