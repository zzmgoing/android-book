# Android进阶学习总结

## 一、JVM与DVM

**1、JVM的内存分配**  

Java 虚拟机在执行 Java 程序的过程中，会把它所管理的内存划分为不同的数据区域。下面这张图描述了一个 HelloWorld.java 文件被 JVM 加载到内存中的过程：

a. HelloWorld.java 文件首先需要经过编译器编译，生成 HelloWorld.class 字节码文件。  
b. Java 程序中访问HelloWorld这个类时，需要通过 ClassLoader(类加载器)将HelloWorld.class 加载到 JVM 的内存中。  
c. JVM 中的内存可以划分为若干个不同的数据区域，主要分为：**程序计数器、虚拟机栈、本地方法栈、堆、方法区**。  

![jvm](https://img.upyun.zzming.cn/android/jvm_fp.png)

![jvm](https://img.upyun.zzming.cn/android/jvm_ing.png)

**总结来说：**  
JVM 的运行时内存结构中一共有两个“栈”和一个“堆”，分别是：**Java虚拟机栈**和**本地方法栈**，以及“**GC堆**”和**方法区**。
除此之外还有一个**程序计数器**，但是我们开发者几乎不会用到这一部分，所以并不是重点学习内容。 
JVM内存中只有**堆**和**方法区**是线程共享的数据区域，其它区域都是线程私有的。
并且程序计数器是唯一一个在 Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

**注意：**  
对于 JVM 运行时内存布局，我们需要始终记住一点：上面介绍的这 5 块内容都是在 Java 虚拟机规范中定义的规则，这些规则只是描述了各个区域是负责做什么事情、存储什么样的数据、如何处理异常、是否允许线程间共享等。千万不要将它们理解为虚拟机的“具体实现”，虚拟机的具体实现有很多，比如 Sun 公司的 HotSpot、JRocket、IBM J9、以及我们非常熟悉的 Android Dalvik 和 ART 等。这些具体实现在符合上面 5 种运行时数据区的前提下，又各自有不同的实现方式。

**2、GC回收机制和分代回收策略**  

垃圾回收指的是JVM回收内存中已经没有用的对象（垃圾）。

不同的虚拟机实现有着不同的 GC 实现机制，但是一般情况下每一种 GC 实现都会在以下两种情况下触发垃圾回收。  
1、Allocation Failure：在堆内存中分配时，如果因为可用剩余空间不足导致对象内存分配失败，这时系统会触发一次 GC。  
2、System.gc()：在应用层，Java 开发工程师可以主动调用此 API 来请求一次 GC。

垃圾收集算法：**标记清除算法（Mark and Sweep GC）**、**复制算法（Copying）**、**标记-压缩算法 (Mark-Compact)**。

**JVM分代回收策略**：  

Java 虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为**新生代**、**老年代**，这就是 JVM 的内存分代策略。注意: 在**HotSpot**中除了新生代和老年代，还有**永久代**。

分代回收的中心思想就是：对于新创建的对象会在新生代中分配内存，此区域的对象生命周期一般较短。如果经过多次回收仍然存活下来，则将它们转移到老年代中。

**引用**

判断对象是否存活我们是通过GC Roots的引用可达性来判断的。但是JVM中的引用关系并不止一种，而是有四种，根据引用强度的由强到弱，
他们分别是:**强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)**。

![yy](https://img.upyun.zzming.cn/android/gc_yy.png)

Android中软引用使用较多，但是不当的使用也会导致异常，比如软引用被强引用持有等。
