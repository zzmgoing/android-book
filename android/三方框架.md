# 三方框架

## OKHttp

OkHttp是一个高性能的http请求库，它通过okio来来进行流的读取和写入，定义了一些基础的io操作方法。然后将请求和回调封装成request和response，通过拦截器来处理各种请求，并返回结果。  

首先通过OkhttpClient创建Call发起同步或异步请求,okhttp会通过dispatcher对我们所有的realcall进行统一管理，并通过execute()或enqueue()方法对请求进行处理，
这两个方法最终会调用RealCall中getResponseWithInterceptorChain()方法，从拦截器中获取返回结果。

**拦截器的作用：**  
RetryAndFollowUpInterceptor：重试拦截器，处理重定向  
BridgeInterceptor：基础的拦截器（设置请求头Cookie、Connection、Content-Type等，做一些返回的处理，保存Cookie等）  
CacheInterceptor：缓存拦截器（在缓存可用的情况下，读取本地的缓存的数据）  
ConnectInterceptor：连接的拦截器（调用findHealthyConnection()：找到一个连接，首先判断有没有健康的，没有就创建（建立socket，握手连接），连接缓存）  
CallServerInterceptor：（给服务器写数据和读取数据；写头部信息，写body表单信息等等）  

Keep-Alive保活机制：当一个http请求完成后，tcp连接不会立即释放，如果有新的http请求，并且host和上次一样，那么可以复用tcp连接，省去重新连接的过程。  
连接3个核心类（连接复用）  
ConnectionPool：保存了连接，管理连接；  
RealConnection：建立连接的一个对象，维护allocations列表；  
StreamAllocation：连接的一些封装；

## Retrofit

Retrofit是基于OkHttp封装的一套网络请求框架。

1、通过注解简化代码  
2、支持自己更换解析的方式，搭配各式的converter来实现
3、restful的api设计风格  
4、支持RxJava  

Retrofit在OkHttp上做了哪些封装？动态代理和静态代理的区别，是怎么实现的。

在Retrofit中使用到了动态代理，使用动态代理，可以无侵入式的扩展代码，在不改动原有代码的情况下，增强一些方法或功能，它的定义是：在程序运行时创建的代理方式。

## RxJava

RxJava是一个基于事件流、实现异步操作的库。

RxJava原理：基于一种扩展的观察者模式，整个模式中有4个角色：  

|角色|作用|
|---|---|
|被观察者（Observable）|产生事件|
|观察者（Observer）|接收事件，并给出响应动作|	
|订阅（Subscribe）|连接 被观察者 & 观察者|
|事件（Event）|被观察者 & 观察者 沟通的载体|

被观察者 （Observable） 通过 订阅（Subscribe） 按顺序发送事件 给观察者 （Observer）  
观察者（Observer） 按顺序接收事件 & 作出对应的响应动作

**线程切换原理**：

```
...
.subscribeOn(Schedulers.newThread())
.subscribeOn(Schedulers.io())
.observeOn(AndroidSchedulers.mainThread())
```

subscribeOn()决定最原始数据源发射数据代码运行的线程，而接下来的发射数据代码是由observeOn决定的。  
observeOn()决定下游代码运行的线程，不定义的话是默认使用当前运行的线程。  

1、如果设置了observeOn(指定线程)，那么Observer（观察者）中的onNext()、onComplete()等方法将会运行在这个指定线程中去。subscribeOn()设置的线程不会影响到observeOn()。

2、如果设置了subscribeOn(指定线程)，那么Observable（被观察者）中subscribe()方法将会运行在这个指定线程中去。

RxJava分配线程时是通过调用链自下而上处理，所以最上面的subscribeOn()会覆盖下面的定义，也就是说subscribeOn()在调用链中最多定义一次就可以，位置任意。

**底层线程实现原理**：  

在IoScheduler中创建和缓存一组线程池并在可以重用时使用它们，主要是通过CachedWorkerPool将ThreadWorker用队列缓存起来，ThreadWorker继承NewThreadWorker，NewThreadWorker通过Executors来创建线程池。

## ARouter

ARouter会在项目的编译期通过注解处理器扫描所有添加@Route注解的Activity类，然后将Route注解中的path地址和Activity.class文件映射关系保存到它自己生成的java文件中。  

## Glide

