# 基础知识

## Android架构

Android系统基于Linux内核开发，由于具有很强的开放性，广泛地应用于手机，平板，车载系统，智能家居等。
Android的架构主要分为五层，由下到上分别是：  
①**Linux kernel内核层**(提供驱动)，  
②**HAL 硬件抽象层**(为特定类型的硬件组件实现界面，如相机或蓝牙)，  
③**原生的C/C++库**(许多核心Android系统组件需要C/C++编写的原生库)和**Android Runtime**(每个应用都有自己的进程和ART实例，ART具有预先和即时编译，优化垃圾回收等)，  
④**Android Framework 应用框架层**(提供资源管理器，内容提供程序，Activity管理器等)，  
⑤**Android Application 应用层**(电子邮件，日历，互联网等系统应用)。  

**Framework层简介**  
Framework层为Android的应用框架层，主要为上层的应用开发提供服务和API接口，包含了三个主要部分，客户端，服务端和Linux驱动。  
客户端主要包括了Activity，ActivityThread，Window，PhoneWindow，WindowManager，DecorView，ViewRoot，W等类。  
服务端主要有WindowManagerService，ActivityManagerService，管理所有应用程序的窗口和页面。还有KeyQ和InputDispatcherThread类处理消息。  
Linux驱动包含了SurfaceFlingger和Binder，SF驱动的作用是把各个Surface显示在同一屏幕上，Binder驱动的作用是提供跨进程（IPC)的消息传递机制。

## 四大组件

### Activity  {docsify-ignore}
> 描述UI，并且处理用户与机器屏幕的交互。

Activity生命周期图

![activity](https://img.upyun.zzming.cn/android/activity.png)

|  回调   |  描述   |
| --- | --- |
|  onCreate()   |  这是第一个回调，在活动第一次创建时调用   |
|  onStart()   |  这个回调在活动为用户可见时被调用   |
|  onResume()   |   这个回调在应用程序与用户开始可交互的时候调用  |
|  onPause()   |  被暂停的活动无法接受用户输入，不能执行任何代码。当前活动将要被暂停，上一个活动将要被恢复时调用   |
|  onStop()   |  当活动不在可见时调用   |
|  onDestroy()   |  当活动被系统销毁之前调用  |
|  onRestart()   |  当活动被停止以后重新打开时调用  |

**Activity启动模式**

1、默认启动模式：**Standard**  
2、栈顶复用模式：**SingleTop**  
3、栈内复用模式：**SingleTask**  
4、全局唯一模式：**SingleInstance**  

### Service  {docsify-ignore}
> 处理与应用程序关联的后台操作。  
> 服务是一个后台运行的组件，执行长时间运行且不需要用户交互的任务，即使应用被销毁也依然可以工作。  

服务有两种运行状态：

|  状态   |  描述   |
| --- | --- |
|  Started   |  Android的应用程序组件，如活动，通过startService()启动了服务，则服务是Started状态。一旦启动，服务可以在后台无限期运行，即使启动它的组件已经被销毁。   |
|  Bound  |  当Android的应用程序组件通过bindService()绑定了服务，则服务是Bound状态。Bound状态的服务提供了一个客户服务器接口来允许组件与服务进行交互，如发送请求，获取结果，甚至通过IPC来进行跨进程通信。   |

Service生命周期图

![service](https://img.upyun.zzming.cn/android/service.png)

在Service的生命周期里，常用的有：

4个手动调用的方法：

|  手动调用方法   |  作用   |
| --- | --- |
|  startService()   |  启动服务   |
|  stopService()   |  关闭服务   |
|  bindService()   |  绑定服务   |
|  unbindService()   |  解绑服务   |

5个自动调用的方法：

|  内部自动调用的方法   |  作用   |
| --- | --- |
|  onCreat()   |  创建服务   |
|  onStartCommand()   |  开始服务   |
|  onDestroy()   |  销毁服务   |
|  onBind()   |  绑定服务   |
|  onUnbind()   |  解绑服务   |

|  回调   |  描述   |
| --- | --- |
|  onCreate()   |  当服务通过onStartCommand()和onBind()被第一次创建的时候，系统调用该方法。该调用要求执行一次性安装。  |
|  onStartCommand()   |  其他组件(如活动)通过调用startService()来请求启动服务时，系统调用该方法。如果你实现该方法，你有责任在工作完成时通过stopSelf()或者stopService()方法来停止服务。  |
|  onBind()   |  当其他组件想要通过bindService()来绑定服务时，系统调用该方法。如果你实现该方法，你需要返回IBinder对象来提供一个接口，以便客户来与服务通信。你必须实现该方法，如果你不允许绑定，则直接返回null。  |
|  onUnbind()   |  当客户中断所有服务发布的特殊接口时，系统调用该方法。  |
|  onRebind()   |  当新的客户端与服务连接，且此前它已经通过onUnbind(Intent)通知断开连接时，系统调用该方法。  |
|  onDestroy()   |  当服务不再有用或者被销毁时，系统调用该方法。你的服务需要实现该方法来清理任何资源，如线程，已注册的监听器，接收器等。  |

### Broadcast Receiver  {docsify-ignore}
> 处理Android操作系统和应用程序之间的通信。  
> 广播接收器用于响应来自其他应用程序或者系统的广播消息。这些消息有时被称为事件或者意图。  

例如，应用程序可以初始化广播来让其他的应用程序知道一些数据已经被下载到设备，并可以为他们所用。这样广播接收器可以定义适当的动作来拦截这些通信。

有以下两个重要的步骤来使系统的广播意图配合广播接收器工作。  
1、创建广播接收器  
2、注册广播接收器  
<span>还有一个附加的步骤，要实现自定义的意图，你必须创建并广播这些意图。</span>

#### 注册广播接收器 {docsify-ignore}

```xml
<application
   android:icon="@drawable/ic_launcher"
   android:label="@string/app_name"
   android:theme="@style/AppTheme" >
   <receiver android:name="cn.programmer.MyReceiver">
//监听系统启动意图，自定义意图
      <intent-filter>
         <action android:name="android.intent.action.BOOT_COMPLETED">
         </action>
         <action android:name="cn.programmer.CUSTOM_INTENT">
         </action>
      </intent-filter>
   </receiver>
</application>
```
#### 广播自定义意图 {docsify-ignore}
```java
// 广播自定义意图
public class Test{
    public void broadcastIntent(View view){
        Intent intent = new Intent();
        intent.setAction("cn.programmer.CUSTOM_INTENT");
        intent.setComponent(new ComponentName("cn.programmer","cn.programmer.MyReceiver"));
        sendBroadcast(intent);
    }
}
```
#### 创建广播接收器 {docsify-ignore}
```java
package cn.programmer;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.widget.Toast;

public class MyReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        Toast.makeText(context, "检测到意图。", Toast.LENGTH_LONG).show();
    }
}
```

### Content Provider  {docsify-ignore}
> 处理数据和数据库管理方面的问题。  
> 内容提供者组件通过请求从一个应用程序向其他的应用程序提供数据。这些请求由类 ContentResolver 的方法来处理。内容提供者可以使用不同的方式来存储数据。数据可以被存放在数据库，文件，甚至是网络。

![content](https://img.upyun.zzming.cn/android/content.jpg)

有时候需要在应用程序之间共享数据。这时内容提供者变得非常有用。  
1、内容提供者可以让内容集中，必要时可以有多个不同的应用程序来访问。  
2、内容提供者的行为和数据库很像。你可以查询，编辑它的内容，使用 insert()， update()， delete() 和 query() 来添加或者删除内容。多数情况下数据被存储在 SQLite 数据库。  
3、 内容提供者被实现为类 **ContentProvider** 类的子类。需要实现一系列标准的 API，以便其他的应用程序来执行事务。  

#### 内容URI {docsify-ignore}
```
<prefix>://<authority>/<data_type>/<id>
```
|  部分   |  说明  |
| --- | --- |
|  prefix   |  前缀：一直被设置为content://   |
|  authority   |  授权：指定内容提供者的名称，例如联系人，浏览器等。第三方的内容提供者可以是全名，如：cn.programmer.statusprovider   |
|  data_type   |  数据类型：这个表明这个特殊的内容提供者中的数据的类型。例如：你要通过内容提供者Contacts来获取所有的通讯录，数据路径是people，那么URI将是下面这样：content://contacts/people   |
|  id   |  这个指定特定的请求记录。例如：你在内容提供者Contacts中查找联系人的ID号为5，那么URI看起来是这样：content://contacts/people/5   |

#### 创建内容提供者 {docsify-ignore}
这里描述创建自己的内容提供者的简单步骤。

1、首先，你需要继承类 ContentProviderbase 来创建一个内容提供者类。  
2、其次，你需要定义用于访问内容的你的内容提供者URI地址。  
3、接下来，你需要创建数据库来保存内容。通常，Android 使用 SQLite 数据库，并在框架中重写 onCreate() 方法来使用 SQLiteOpenHelper 的方法创建或者打开提供者的数据库。当你的应用程序被启动，它的每个内容提供者的 onCreate() 方法将在应用程序主线程中被调用。  
4、最后，使用标签在 AndroidManifest.xml 中注册内容提供者。  

以下是让你的内容提供者正常工作，你需要在类 ContentProvider 中重写的一些方法：

|  部分   |  说明  |
| --- | --- |
|  onCreate()   |  当提供者被启动时调用   |
|  query()   |  该方法从客户端接受请求，结果是返回指针(Cursor)对象   |
|  insert()   |  该方法向内容提供者插入新的记录   |
|  delete()   |  该方法从内容提供者中删除已存在的记录   |
|  update()   |  该方法更新内容提供者中已存在的记录   |
|  getType()   |  该方法为给定的URI返回元数据类型   |

## View绘制流程

自定义View绘制流程函数调用链(简化版)

![view](https://img.upyun.zzming.cn/android/zdy_view.jpg)

**OnMeasure()：** 测量视图大小。从顶层父View到子View递归调用measure方法，measure方法又回调OnMeasure。

**OnLayout()：** 确定View位置，进行页面布局。从顶层父View向子View的递归调用view.layout方法的过程，即父View根据上一步measure子View所得到的布局大小和布局参数，将子View放在合适的位置上。

**OnDraw()：** 绘制视图。ViewRoot创建一个Canvas对象，然后调用OnDraw()。六个步骤：①、绘制视图的背景；②、保存画布的图层（Layer）；③、绘制View的内容；④、绘制View子视图，如果没有就不用；⑤、还原图层（Layer）；⑥、绘制滚动条。

**invalidate()和requestLayout()的不同**

requestLayout()会直接递归调用父窗口的requestLayout()，直到ViewRootImpl,然后触发peformTraversals，**由于mLayoutRequested为true，会导致onMeasure()和onLayout()被调用，不一定会触发OnDraw()。** requestLayout()触发onDraw()可能是因为在在layout过程中发现l,t,r,b和以前不一样，那就会触发一次invalidate()，所以触发了onDraw()，也可能是因为别的原因导致mDirty非空（比如在跑动画）

view的invalidate()不会导致ViewRootImpl的invalidate()被调用，而是递归调用父view的invalidateChildInParent()，直到ViewRootImpl的invalidateChildInParent()，然后触发performTraversals，会导致当前view被重绘,**由于mLayoutRequested为false，不会导致onMeasure()和onLayout()被调用，而OnDraw()会被调用**。

postInvalidate是在非UI线程中调用，invalidate则是在UI线程中调用。

**自定义ViewGroup**  
自定义ViewGroup一般是利用现有的组件根据特定的布局方式来组成新的组件，大多继承自ViewGroup或各种Layout，包含有子View。

**自定义View**  
在没有现成的View，需要自己实现的时候，就使用自定义View，一般继承自View，SurfaceView或其他的View，不包含子View。

**继承原生控件**  
继承如TextView，ImageView，Button等原生控件进行拓展。

> [Android自定义View教程目录](https://www.gcssloop.com/category/customview)

## Binder机制

**Binder**  
一种进程间通信(IPC)机制, 基于OpenBinder

1、Binder是Android提供的一套进程间通信框架。  
2、系统服务ActivityManagerService,LocationManagerService等在framework层都是在单独进程中的，使用binder和应用进行通信。  
Android应用和系统services运行在不同进程中是为了安全，稳定，以及内存管理的原因，但是应用和系统服务需要通信和分享数据。

Binder驱动程序实现在内核空间中，开发者在用户空间实现自己的client和server。

Binder的整体设计总共有四层：  
1、Java层AIDL  
2、Framework层， Android.os.Binder  
3、Native 层: libBinder.cpp  
4、内核层内核层的通信都是通过ioctl来进行的，client打开一个ioctl,进入到轮询队列，一直阻塞直到时间到或者有消息。

Binder中使用的设计模式为代理模式。

**Binder的优势**

| 优势	 | 描述 |
| --- | --- |
| 性能 | 只需要一次数据拷贝，性能上仅次于共享内存| 
| 稳定性 | 基于 C/S 架构，职责明确、架构清晰，因此稳定性好| 
| 安全性 | 为每个 APP 分配 UID，进程的 UID 是鉴别进程身份的重要标志| 

**进程间通信方式**

1、Files 文件系统（包括内存映射）  
2、Sockets  
3、Pipes 管道  
4、共享内存  
5、Intents, ContentProviders, Messenger  
6、Binder  

## AIDL进程间通信

AIDL（Android Interface Definition Language）是Android系统自定义的接口描述语言，可以用来实现进程间的通讯。

**AIDL支持的数据类型**  
1、八种基本数据类型：byte、char、short、int、long、float、double、boolean  
2、String，CharSequence  
3、实现了Parcelable接口的数据类型  
4、ArrayList和HashMap类型(承载的数据必须是AIDL支持的类型，或者是其它声明的AIDL对象)  

**服务端**  
1、创建.aidl文件（定义编程接口和方法）。  
2、实现接口。  
Android SDK工具基于.aidl文件生成接口文件。这个接口有一个名叫Stub的内部抽象类，Stub扩展了Binder并实现了AIDL接口中声明的方法。  
3、暴露接口给客户端。  
实现一个Service重写onBind()，onBind()返回实现了Stub的类。

**客户端**  
1、将服务端aidl文件和相关实体类拷贝过来（文件目录应该与服务端相同，包名应该一样）。  
2、编译后通过bindService使用ServiceConnection来获取binder对象，即可调用服务端方法。  
```java
public class Activity{
    public void onCreate(){
        Intent intent = new Intent(this, AIDLService.class);
        bindService(intent, new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                LogUtil.d("onServiceConnected");
                Demo demo = Demo.Stub.asInterface(service);
            }
        
            @Override
            public void onServiceDisconnected(ComponentName name) {
                LogUtil.d("onServiceDisconnected");
            }
        }, BIND_AUTO_CREATE);
    }
}
```

## 数据存储

Android数据存储的五种方式：  

**一、SharedPreferences**

存储路径：```/data/data/{包名}/shared_prefs/<文件名>```  
属于文件存储的一种，利用xml存储键值对，用来保存应用的一些常用配置。

**二、文件存储**

内部存储(对用户不可见)：
```
/data/data/{packageName}/
getFilesDir(); // 返回 /data/data/{packageName}/files/  文件夹
fileList(); // 返回files/下的所有文件名字的数组
deleteFile(fileName); // 删除files/下 文件名为fileName的文件
```

外部存储：
```
//应用私有目录,无需读写权限
getExternalFilesDir() ```/storage/emulated/0/Android/data/{packageName}/files```  
getExternalCacheDir() ```/storage/emulated/0/Android/data/{packageName}/cache```

//公有目录，需要申请读写权限
Environment.getExternalStorageDirectory() ```/storage/emulated/0```  
```

**三、SQLite数据库**

SQLite是一个嵌入型的轻量级数据库，适合小数据量。

**通过SQLiteOpenHelper创建数据库**

1、创建该对象后并不会回调onCreate(),onOpen()方法。  
2、调用该对象的getWritableDatabase()或getReadableDatabase()返回SQLiteDatabase对象，才会回调onCreate(),onOpen()方法。  
3、此时会在```/data/data/{packageName}/databases```路径下生成创建的db。

**getWritableDatabase()**：以读写方式打开数据库，一旦数据库的磁盘空间满了，数据库就只能读而不能写，使用该方式就会报异常。    
**getReadableDatabase()**：先以读写方式打开数据库，如果数据库的磁盘空间满了，就会打开失败，然后会尝试以只读方式打开数据库，返回只可读的实例。

**四、ContentProvider**

一个程序可以通过实现一个ContentProvider的抽象接口将自己的数据完全暴露出去，而且ContentProviders是以类似数据库中表的方式将数据暴露，也就是说ContentProvider就像一个“数据库”。那么外界获取其提供的数据，也就应该与从数据库中获取数据的操作基 本一样，只不过是采用URI来表示外界需要访问的“数据库”。

**五、网络存储**

## Animation动画

**传统动画（帧动画、补间动画）**

帧动画：最容易实现的一种动画，将一张张图片连贯起来播放。

补间动画：alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）。
  
**属性动画（基于对象属性的动画）**  
<span>所有补间动画都可以用属性动画实现</span>

Android 3.0（API 11）后才提供的一种全新动画模式，出现原因为作用对象局限于View，没有改变View的属性，只是改变视觉效果，动画效果单一。  
ValueAnimator、ObjectAnimator是其重要的两个类。  
ValueAnimator有ofInt、ofFloat、ofObject三个重要的方法。  
方法的作用：1.创建动画实例2.将传入的多个参数进行平滑过渡:此处传入0和1，表示将值从0平滑过渡到1 ，如果传入了3个Int参数 a,b,c ,则是先从a平滑过渡到b,再从b平滑过渡到c，以此类推,他们内置了估值器。

**ValueAnimator**：可以设置开始值和结束值来动态改变view的移动位置。  
**ObjectAnimator**：功能更加强大，可以控制位移、透明度、旋转、缩放。

**插值器**（Interpolator）：决定值的变化模式  
**估值器**（TypeEvaluator）：决定值的具体变化数值  

插值器决定值的变化模式，默认的种类有九个：  
AccelerateDecelerateInterpolator ：在动画开始与结束的地方速率改变比较慢，在中间的时候加速  
AccelerateInterpolator：在动画开始的地方速率改变比较慢，然后开始速率变化加快  
**LinearInterpolator**：以常量速率改变  
AnticipateInterpolator：开始的时候向后然后向前甩  
**CycleInterpolator**：动画循环播放特定的次数，速率改变沿着正弦曲线  
**PathInterpolator**：动画执行的效果按贝塞尔曲线  
anticipateOvershootInterpolator：开始的时候向后然后向前甩一定值后返回最后的值  
OvershootInterpolator：向前甩一定值后再回到原来位置  
BounceInterpolator：动画结束的时候有弹起效果  

自定义插值器：  
写一个类实现Interpolator接口，Interpolator是一个空的接口继承了TimeInterpolator接口，定义getInterpolation方法即可。

```java
public class Demo{
    private void RotateAnimation() {
        ObjectAnimator anim = ObjectAnimator.ofFloat(myView, "rotation", 0f, 360f);
        anim.setDuration(1000);
        anim.start();
    }
    private void AlpahAnimation() {
        ObjectAnimator anim = ObjectAnimator.ofFloat(myView, "alpha", 1.0f, 0.8f, 0.6f, 0.4f, 0.2f, 0.0f);
        anim.setRepeatCount(-1);
        anim.setRepeatMode(ObjectAnimator.REVERSE);
        anim.setDuration(2000);
        anim.start();
    }
}
```

**补间动画和属性动画的区别**

补间动画只是绘制了一个不同的影子，view对象还在原来的位置。  
(比如位移后点击原来的位置会响应点击事件，旋转后再次旋转会从头开始重新旋转)  
而**属性动画则是真正的视图移动**，例如点击移动后的视图会响应点击事件。


